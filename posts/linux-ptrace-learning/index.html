<!doctype html><html lang=zh-cn><head><meta charset=utf-8><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><meta name=viewport content="width=device-width,initial-scale=1"><title>Linux ptrace机制初探 - zznQ</title><meta name=author content="zznq"><meta property="og:title" content="Linux ptrace机制初探"><meta property="og:description" content="补充下基础知识 动态加载 动态加载Dynamic Loading：是一种程序运行机制，能让计算机程序在运行时（而不是编译时）装载库（或者其他二进制对象）到内存中，然后检索库中函数和变量的地址，并运行这些函数或访问这些变量，且能在不需要时将库从内存中卸载。
linux下的/proc虚拟文件系统 Linux 内核提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。
 /proc/<PID>/status / /proc/<PID>/stat： 查看进程信息 /proc/<PID>/maps：进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表 /proc/self/maps： 当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。  什么是 Ptrace？ 通过使用 ptrace（名称是 &ldquo;process trace&rdquo; 的缩写），一个进程可以控制另一个进程，从而使控制器能够检查和操纵目标的内部状态。
linux ptrace 函数提供了许多有用的调试操作：
 PTRACE_ATTACH 允许一个进程将自身附加到另一个进程进行调试，从而暂停远程进程。 PTRACE_PEEKTEXT 允许从另一个进程地址空间读取内存。 PTRACE_POKETEXT 允许将内存写入另一个进程地址空间。 PTRACE_GETREGS 从进程中读取当前的处理器寄存器集。 PTRACE_SETREGS 写入进程的当前处理器寄存器集。 PTRACE_CONT 恢复附加进程的执行。 PTRACE_DETACH 是重新启动操作；它要求目标进程处于 ptrace-stop 中。  函数签名：
long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); 🌰 （Linux ubuntu 4.15.0-112-generic x86_64）:
#include <stdio.h>#include <sys/types.h>#include <sys/wait.h>#include <sys/ptrace.h>#include <unistd.h>#include <sys/user.h> int main(int argc, char **argv) {  int child_pid;  child_pid = fork();  if (child_pid == 0)  {  // `PTRACE_TRACEME` 本进程将被其父进程跟踪(此时剩下的`pid、addr、data`参数都没有实际意义可以全部为 0)。  ptrace(PTRACE_TRACEME, 0, 0, 0);  execl(&#34;/bin/ls&#34;,&#34;ls&#34;,NULL); //执行系统调用  }  else  {  struct user_regs_struct regs;  wait(NULL);  printf(&#34;child process was stopped ."><meta property="og:type" content="article"><meta property="og:url" content="https://zznq.imipy.com/posts/linux-ptrace-learning/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-10T00:00:00+00:00"><meta property="article:modified_time" content="2020-12-10T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux ptrace机制初探"><meta name=twitter:description content="补充下基础知识 动态加载 动态加载Dynamic Loading：是一种程序运行机制，能让计算机程序在运行时（而不是编译时）装载库（或者其他二进制对象）到内存中，然后检索库中函数和变量的地址，并运行这些函数或访问这些变量，且能在不需要时将库从内存中卸载。
linux下的/proc虚拟文件系统 Linux 内核提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。
 /proc/<PID>/status / /proc/<PID>/stat： 查看进程信息 /proc/<PID>/maps：进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表 /proc/self/maps： 当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。  什么是 Ptrace？ 通过使用 ptrace（名称是 &ldquo;process trace&rdquo; 的缩写），一个进程可以控制另一个进程，从而使控制器能够检查和操纵目标的内部状态。
linux ptrace 函数提供了许多有用的调试操作：
 PTRACE_ATTACH 允许一个进程将自身附加到另一个进程进行调试，从而暂停远程进程。 PTRACE_PEEKTEXT 允许从另一个进程地址空间读取内存。 PTRACE_POKETEXT 允许将内存写入另一个进程地址空间。 PTRACE_GETREGS 从进程中读取当前的处理器寄存器集。 PTRACE_SETREGS 写入进程的当前处理器寄存器集。 PTRACE_CONT 恢复附加进程的执行。 PTRACE_DETACH 是重新启动操作；它要求目标进程处于 ptrace-stop 中。  函数签名：
long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); 🌰 （Linux ubuntu 4.15.0-112-generic x86_64）:
#include <stdio.h>#include <sys/types.h>#include <sys/wait.h>#include <sys/ptrace.h>#include <unistd.h>#include <sys/user.h> int main(int argc, char **argv) {  int child_pid;  child_pid = fork();  if (child_pid == 0)  {  // `PTRACE_TRACEME` 本进程将被其父进程跟踪(此时剩下的`pid、addr、data`参数都没有实际意义可以全部为 0)。  ptrace(PTRACE_TRACEME, 0, 0, 0);  execl(&#34;/bin/ls&#34;,&#34;ls&#34;,NULL); //执行系统调用  }  else  {  struct user_regs_struct regs;  wait(NULL);  printf(&#34;child process was stopped ."><link rel=stylesheet href=/style.min.5297c96c59a52afaa5bcda4a6cedf3813081f64025c209b25b2ee6d0c8f74d462b625ad3404a92a14d7a51b4ec0a420337ae70f426fa4bce2d5f7459a3ca7274.css integrity="sha512-UpfJbFmlKvqlvNpKbO3zgTCB9kAlwgmyWy7m0Mj3TUYrYlrTQEqSoU16UbTsCkIDN65w9Cb6S84tX3RZo8pydA=="><script>localStorage.theme==="dark"||!("theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.setAttribute("data-theme","dark"):document.documentElement.setAttribute("data-theme","light")</script><script defer src=/js/header.7a2a109ec3782c57bad0332b662f8a5f41765505936b69868eb8bd5241de9daf23c388e82ca1831f6d09935013dcb9f71bfa7face3975880c1076028b7b0a6e1.js integrity="sha512-eioQnsN4LFe60DMrZi+KX0F2VQWTa2mGjri9UkHena8jw4joLKGDH20Jk1AT3Ln3G/p/rOOXWIDBB2Aot7Cm4Q=="></script>
<script defer src=/js/builtin-copy.56e07a74dd440b068ab36af35542ed8960865686c19fb809f38436877ac081570612cc8a913650b0c0e3073a336680c5df960e73bf7b1de83dc6aa996f2db858.js integrity="sha512-VuB6dN1ECwaKs2rzVULtiWCGVobBn7gJ84Q2h3rAgVcGEsyKkTZQsMDjBzozZoDF35YOc797Heg9xqqZby24WA=="></script>
<script defer src=/js/search-zh-cn.677e05c714f837051483647d736c45051126c22a2696ca5f981b59da962d48962f3ea71150f559ba84884fd1aadf1c7aadce55bb31a3e5b75c0f173b763c109a.js integrity="sha512-Z34FxxT4NwUUg2R9c2xFBREmwiomlspfmBtZ2pYtSJYvPqcRUPVZuoSIT9Gq3xx6rc5VuzGj5bdcDxc7djwQmg=="></script></head><body><main><header><div class=brand><div id=sidebar_btn><svg id="menu_icon" width="26" height="26" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></svg></div><div><a href=/>zznQ🎈</a></div></div><div class=toolbox><div id=theme_tool><svg id="dark_mode_btn" class="hidden toolbox-btn" width="18" height="18" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></svg><svg id="light_mode_btn" class="hidden toolbox-btn" width="18" height="18" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></svg></div><div id=search_tool><svg id="search_btn" class="toolbox-btn" width="18" height="18" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg></svg><div id=search_menu_wrapper class=hidden><div id=search_menu><div id=search_menu_toolbar><div id=search_menu_input_wrapper><input id=search_menu_input type=text placeholder="Search Posts"></div><div id=search_menu_close_btn><svg width="18" height="18" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></svg></div></div><div id=search_menu_results></div></div></div></div></div></header><nav id=navbar class=pure-menu><ul class=pure-menu-list><li class="navbar-item pure-menu-item insection"><a href=/posts/ class=pure-menu-link>文章</a></li><li class="navbar-item pure-menu-item"><a href=/categories/ class=pure-menu-link>分类</a></li><li class="navbar-item pure-menu-item"><a href=/tags/ class=pure-menu-link>标签</a></li></ul></nav><div id=sidebar_canvas_overlay class=hidden></div><div id=sidebar class=close><ul><li><a href=/posts/>文章</a></li><li><a href=/categories/>分类</a></li><li><a href=/tags/>标签</a></li></ul></div><div id=content class=content-margin><details class=collapsible-menu-wrapper><summary class=collapsible-menu-type><span>Table of contents</span></summary><div class=collapsible-menu><nav id=TableOfContents><ul><li><a href=#补充下基础知识>补充下基础知识</a><ul><li><a href=#动态加载>动态加载</a></li><li><a href=#linux下的proc虚拟文件系统>linux下的/proc虚拟文件系统</a></li><li><a href=#什么是-ptrace>什么是 Ptrace？</a></li></ul></li><li><a href=#踩坑-sshd-注入>踩坑 SSHD 注入</a></li><li><a href=#笔记>笔记📒</a><ul><li><a href=#进程相关>进程相关：</a></li><li><a href=#动态加载-1>动态加载</a></li><li><a href=#内存相关>内存相关</a></li><li><a href=#字符处理>字符处理</a></li><li><a href=#其他>其他</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#参考文章>参考文章🙏</a></li></ul></nav></div></details><div class=content-margin><article class=line-numbers><h2 id=补充下基础知识>补充下基础知识</h2><h3 id=动态加载>动态加载</h3><p>动态加载<code>Dynamic Loading</code>：是一种程序运行机制，能让计算机程序在运行时（而不是编译时）装载库（或者其他二进制对象）到内存中，然后检索库中函数和变量的地址，并运行这些函数或访问这些变量，且能在不需要时将库从内存中卸载。</p><h3 id=linux下的proc虚拟文件系统>linux下的/proc虚拟文件系统</h3><p>Linux 内核提供了一种通过 <code>/proc</code> 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。</p><ul><li><code>/proc/&lt;PID>/status</code> / <code>/proc/&lt;PID>/stat</code>： 查看进程信息</li><li><code>/proc/&lt;PID>/maps</code>：进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表</li><li><code>/proc/self/maps</code>： 当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。</li></ul><h3 id=什么是-ptrace>什么是 Ptrace？</h3><p>通过使用 ptrace（名称是 &ldquo;process trace&rdquo; 的缩写），一个进程可以控制另一个进程，从而使控制器能够检查和操纵目标的内部状态。</p><p>linux ptrace 函数提供了许多有用的调试操作：</p><ul><li><code>PTRACE_ATTACH</code> 允许一个进程将自身附加到另一个进程进行调试，从而暂停远程进程。</li><li><code>PTRACE_PEEKTEXT</code> 允许从另一个进程地址空间读取内存。</li><li><code>PTRACE_POKETEXT</code> 允许将内存写入另一个进程地址空间。</li><li><code>PTRACE_GETREGS</code> 从进程中读取当前的处理器寄存器集。</li><li><code>PTRACE_SETREGS</code> 写入进程的当前处理器寄存器集。</li><li><code>PTRACE_CONT</code> 恢复附加进程的执行。</li><li><code>PTRACE_DETACH</code> 是重新启动操作；它要求目标进程处于 <code>ptrace-stop</code> 中。</li></ul><p>函数签名：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#a6e22e>ptrace</span>(<span style=color:#66d9ef>enum</span> __ptrace_request request, pid_t pid, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>addr, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>data);
</span></span></code></pre></div><p>🌰 （Linux ubuntu 4.15.0-112-generic x86_64）:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/wait.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/ptrace.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/user.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> child_pid;
</span></span><span style=display:flex><span>    child_pid <span style=color:#f92672>=</span> fork();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (child_pid <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// `PTRACE_TRACEME` 本进程将被其父进程跟踪(此时剩下的`pid、addr、data`参数都没有实际意义可以全部为 0)。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ptrace(PTRACE_TRACEME, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        execl(<span style=color:#e6db74>&#34;/bin/ls&#34;</span>,<span style=color:#e6db74>&#34;ls&#34;</span>,NULL); <span style=color:#75715e>//执行系统调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> user_regs_struct regs;
</span></span><span style=display:flex><span>        wait(NULL);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;child process was stopped ...&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 读取子进程寄存器集
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ptrace(PTRACE_GETREGS, child_pid, NULL, <span style=color:#f92672>&amp;</span>regs);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%llu&#34;</span>, regs.orig_rax);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 恢复子进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ptrace(PTRACE_CONT, child_pid, NULL, NULL);
</span></span><span style=display:flex><span>        sleep(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=踩坑-sshd-注入>踩坑 SSHD 注入</h2><blockquote><p><a href=https://github.com/xpn/ssh-inject>https://github.com/xpn/ssh-inject</a></p></blockquote><p>分析下代码其运行流程图整理如下：</p><p><img src=https://user-images.githubusercontent.com/26270009/101984608-856e0e80-3cbd-11eb-8d8c-e56a51ee31ee.png alt></p><p><a href=https://github.com/xpn/ssh-inject/blob/master/inject.c>inject.c</a> 和 <a href=https://github.com/xpn/ssh-inject/blob/master/injectme.c>injectme.c</a> 中一些注入部分代码细节和 hook 代码细节已经看不懂了，先挖个坑吧&mldr;</p><p><a href=https://blog.xpnsec.com/linux-process-injection-aka-injecting-into-sshd-for-fun/>Linux ptrace introduction AKA injecting into sshd for fun</a> 原博客中有关于 ptarce 步骤更详细说明。</p><h2 id=笔记>笔记📒</h2><h3 id=进程相关>进程相关：</h3><ul><li><code>pid_t fork(void)</code> 在当前进程下分叉出子进程，其子进程的 pid 为 0</li><li><code>pid_t wait (int * status)</code> 等待子进程中断或结束</li><li><code>pid_t waitpid(pid_t pid, int *status, int options);</code>（等待子进程中断或结束）</li></ul><pre tabindex=0><code>pid: 
    - pid&lt;-1 等待进程组识别码为pid绝对值的任何子进程。
    - pid=-1 等待任何子进程，相当于wait()。
    - pid=0 等待进程组识别码与目前进程相同的任何子进程。
    - pid&gt;0 等待任何子进程识别码为pid的子进程。

status(子进程的结束状态返回后存于status，底下有几个宏可判别结束情况):
    - WIFEXITED(status) 如果子进程正常结束则为非0值。
    - WEXITSTATUS(status) 取得子进程exit()返回的结束代码，一般会先用WIFEXITED 来判断是否正常结束才能使用此宏。
    - WIFSIGNALED(status) 如果子进程是因为信号而结束则此宏值为真
    - WTERMSIG(status) 取得子进程因信号而中止的信号代码，一般会先用WIFSIGNALED 来判断后才使用此宏。
    - WIFSTOPPED(status) 如果子进程处于暂停执行情况则此宏值为真。一般只有使用 WUNTRACED 时才会有此情况。
    - WSTOPSIG(status) 取得引发子进程暂停的信号代码，一般会先用WIFSTOPPED 来判断后才使用此宏。

options: 可以为 0 或下面的 OR 组合
    - WNOHANG 如果没有任何已经结束的子进程则马上返回，不予以等待。
    - WUNTRACED 如果子进程进入暂停执行情况则马上返回，但结束状态不予以理会。
</code></pre><ul><li><code>exec</code> 系列函数用来执行文件或者命令</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> execl(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>path, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>arg, ...);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>execlp</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>file, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>arg, ...);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>execle</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>path, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>arg, ..., <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> envp[]);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>execv</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>path, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> argv[]);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>execvp</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>file, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> argv[]);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>execve</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>path, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> argv[], <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> envp[]);
</span></span></code></pre></div><p><strong>注意：</strong> 系统调用 exec 是以新的进程去代替原来的进程，但进程的 PID 保持不变，只是替换了原来进程上下文的内容，原进程的代码段，数据段，堆栈段被新的进程所代替。</p><h3 id=动态加载-1>动态加载</h3><p>在 <code>dlopen()</code> 函数以指定模式打开指定的动态链接库文件，并返回一个句柄给 <code>dlsym()</code> 的调用进程。使用 <code>dlclose()</code> 来卸载打开的库。</p><ul><li><code>void * dlopen( const char *pathname, int mode ); </code>：打开一个动态链接库。</li></ul><p>mode 是打开方式，其值有多个，不同操作系统上实现的功能有所不同，在 linux 下，按功能可分为三类：</p><ol><li>解析方式<ul><li><code>RTLD_LAZY</code>：在 <code>dlopen()</code> 返回前，对于动态库中的未定义的符号不执行解析（只对函数引用有效，对于变量引用总是立即解析）。</li><li><code>RTLD_NOW</code>： 需要在 <code>dlopen()</code> 返回前，解析出所有未定义符号，如果解析不出来，在 <code>dlopen()</code> 会返回 <code>NULL</code>，错误为：: undefined symbol: xxxx&mldr;&mldr;.</li></ul></li><li>作用范围，可与解析方式通过 <code>|</code> 组合使用。<ul><li><code>RTLD_GLOBAL</code>：动态库中定义的符号可被其后打开的其它库解析。</li><li><code>RTLD_LOCAL</code>： 与 <code>RTLD_GLOBAL</code> 作用相反，动态库中定义的符号不能被其后打开的其它库重定位。如果没有指明是 <code>RTLD_GLOBAL</code>还是 <code>RTLD_LOCAL</code> ，则缺省为 <code>RTLD_LOCAL</code>。</li></ul></li><li>作用方式<ul><li><code>RTLD_NODELETE</code>： 在 <code>dlclose()</code> 期间不卸载库，并且在以后使用 <code>dlopen()</code> 重新加载库时不初始化库中的静态变量。这个flag不是POSIX-2001标准。</li><li><code>RTLD_NOLOAD</code>： 不加载库。可用于测试库是否已加载( <code>dlopen()</code> 返回NULL说明未加载，否则说明已加载），也可用于改变已加载库的flag，如：先前加载库的flag为 <code>RTLD_LOCAL</code>，用 <code>dlopen(RTLD_NOLOAD|RTLD_GLOBAL)</code> 后flag将变成 <code>RTLD_GLOBAL</code> 。这个flag不是POSIX-2001标准。</li><li><code>RTLD_DEEPBIND</code>：在搜索全局符号前先搜索库内的符号，避免同名符号的冲突。这个flag不是POSIX-2001标准。</li></ul></li></ol><ul><li><code>void * dlsym(void *handle, const char *symbol)</code>：<code>dlsym()</code> 根据动态链接库操作句柄 <code>handle</code> 与符号 <code>symbol</code> ，返回符号对应的地址。使用这个函数不但可以获取函数地址，也可以获取变量地址。</li></ul><p><code>handle</code> 是由 <code>dlopen()</code> 打开动态链接库后返回的指针，<code>symbol</code> 就是要求获取的函数或全局变量的名称。
返回值: <code>void*</code> 指向函数的地址，供调用使用。</p><ul><li><p><code>dlclose()</code> 用于关闭指定句柄的动态链接库，只有当此动态链接库的使用计数为 0 时,才会真正被系统卸载。</p></li><li><p><code>dlerror()</code> 当动态链接库操作函数执行失败时，<code>dlerror</code> 可以返回出错信息，返回值为 <code>NULL</code> 时表示操作函数执行成功。</p></li></ul><h3 id=内存相关>内存相关</h3><ul><li><code>void * malloc(size_t size)</code>：分配所需的内存空间，并返回一个指向它的指针；记得需要运行 free(addr` )</li><li><code>void * memcpy(void *dest, const void *src, size_t num);</code>： 会复制 src 所指的内存内容的前 num 个字节到 dest 所指的内存地址上。</li></ul><h3 id=字符处理>字符处理</h3><ul><li><code>int snprintf(char *str, size_t size, const char *format, ...);</code></li></ul><p>设将可变参数 <code>...</code> 按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断。</p><ul><li><code>char *strstr(const char *haystack, const char *needle);</code></li></ul><p>在字符串 haystack 中查找第一次出现字符串 needle 的位置，不包含终止符 &lsquo;\0&rsquo;。该函数返回在 haystack 中第一次出现 needle 字符串的位置，如果未找到则返回 null。</p><ul><li><code>unsigned long int strtoul(const char *str, char **endptr, int base);</code></li></ul><p>把参数 str 所指向的字符串根据给定的 base 转换为一个无符号长整数（类型为 <code>unsigned long int</code> 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0。</p><ul><li><code>int sscanf(const char *str, const char *format, ...);</code> 从字符串读取格式化输入。</li></ul><h3 id=其他>其他</h3><ul><li>struct 运算符 <code>.</code> 和箭头运算符 <code>-></code> 异同点：<ul><li>相同点：两者都是二元操作符，而且右边的操作数都是成员的名称。</li><li>不同点：点运算符 <code>.</code> 的左边操作数是一个结果为结构的<strong>表达式</strong>；
箭头运算符 <code>-></code> 的左边的操作数是一个指向结构体的<strong>指针</strong>。</li></ul></li></ul><h2 id=总结>总结</h2><p>浅显的认知 Linux 下进程运行的机制，ptrace 的如何动态注入基本过程，C语言的基本用法等。。。</p><h2 id=参考文章>参考文章🙏</h2><ul><li><a href=https://en.wikipedia.org/wiki/Ptrace>linux ptrace wiki</a></li><li><a href=https://linux.die.net/man/2/ptrace>linux ptrace 手册</a></li><li><a href=http://net.pku.edu.cn/~yhf/linux_c/function/11.html#linuxc196>linux wait waitpid 手册</a></li><li><a href=https://xz.aliyun.com/t/6882>《Linux逆向之调试&反调试》</a></li><li><a href=https://blog.csdn.net/freeelinux/article/details/53782986>《Linux虚拟地址空间布局以及进程栈和线程栈总结》</a></li><li><a href=https://blog.xpnsec.com/linux-process-injection-aka-injecting-into-sshd-for-fun/>Linux ptrace introduction AKA injecting into sshd for fun</a></li><li><a href=https://github.com/xpn/ssh-inject>https://github.com/xpn/ssh-inject</a></li></ul></article><script src=https://utteranc.es/client.js repo=Buzz2d0/zznq issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer><article>Copyright © 2019-2022 by zznq</article></footer></main></body></html>