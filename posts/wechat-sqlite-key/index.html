<!doctype html><html lang=zh-cn><head><meta charset=utf-8><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><meta name=viewport content="width=device-width,initial-scale=1"><title>逆向获取 MacOS WeChat App 聊天数据库密钥小记 - zznQ</title><meta name=author content="zznq"><meta property="og:title" content="逆向获取 MacOS WeChat App 聊天数据库密钥小记"><meta property="og:description" content="突然想解密下 WeChat 本地聊天数据库 ，这些 msg_*.db 文件一般存在 ~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application\ Support/com.tencent.xinWeChat/2.*******/123812fsdhg1232333sd/Message/ 目录下
google 发现一个教程：https://github.com/allen1881996/WeChat-Data-Analysis 测试后发现这个操作是可行的。大概步骤如下：通过 lldb 动态调试对 sqlite3_key 函数断点后再读取 $rsi 寄存器的值，进行简单拼接即得到了 sqlite3 raw-key。
但是心中出现了两个疑问：
 为什么是 sqlite3_key?  Tencent有个开源项目 wcdb 是基于SQLite的，加密使用的是开源的 SQLCipher sqlite3_key 函数就是设置加密数据库的。wcdb 将其封装在了 setCipherKey 方法下。
memory read --size 1 --format x --count 32 $rsi 是啥意思？  x86-64 中函数调用时的参数存储如下寄存器中: %rdi, %rsi, %rdx, %rcx, %r8, %r9 六个寄存器用于存储函数调用时的6个参数（如果有6个或6个以上参数的话）。
%rsi 寄存器存储的为第二个参数，即对应 int sqlite3_key(sqlite3 *db, const void *pKey, int nKey); 中 key 。
 如何能通过静态的方式获取到 key 呢？ 根据 WCDB 的线索继续摸索，找到在哪里执行 setCipherKey"><meta property="og:type" content="article"><meta property="og:url" content="https://zznq.imipy.com/posts/wechat-sqlite-key/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-15T00:00:00+00:00"><meta property="article:modified_time" content="2021-07-15T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="逆向获取 MacOS WeChat App 聊天数据库密钥小记"><meta name=twitter:description content="突然想解密下 WeChat 本地聊天数据库 ，这些 msg_*.db 文件一般存在 ~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application\ Support/com.tencent.xinWeChat/2.*******/123812fsdhg1232333sd/Message/ 目录下
google 发现一个教程：https://github.com/allen1881996/WeChat-Data-Analysis 测试后发现这个操作是可行的。大概步骤如下：通过 lldb 动态调试对 sqlite3_key 函数断点后再读取 $rsi 寄存器的值，进行简单拼接即得到了 sqlite3 raw-key。
但是心中出现了两个疑问：
 为什么是 sqlite3_key?  Tencent有个开源项目 wcdb 是基于SQLite的，加密使用的是开源的 SQLCipher sqlite3_key 函数就是设置加密数据库的。wcdb 将其封装在了 setCipherKey 方法下。
memory read --size 1 --format x --count 32 $rsi 是啥意思？  x86-64 中函数调用时的参数存储如下寄存器中: %rdi, %rsi, %rdx, %rcx, %r8, %r9 六个寄存器用于存储函数调用时的6个参数（如果有6个或6个以上参数的话）。
%rsi 寄存器存储的为第二个参数，即对应 int sqlite3_key(sqlite3 *db, const void *pKey, int nKey); 中 key 。
 如何能通过静态的方式获取到 key 呢？ 根据 WCDB 的线索继续摸索，找到在哪里执行 setCipherKey"><link rel=stylesheet href=/style.min.5297c96c59a52afaa5bcda4a6cedf3813081f64025c209b25b2ee6d0c8f74d462b625ad3404a92a14d7a51b4ec0a420337ae70f426fa4bce2d5f7459a3ca7274.css integrity="sha512-UpfJbFmlKvqlvNpKbO3zgTCB9kAlwgmyWy7m0Mj3TUYrYlrTQEqSoU16UbTsCkIDN65w9Cb6S84tX3RZo8pydA=="><script>localStorage.theme==="dark"||!("theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.setAttribute("data-theme","dark"):document.documentElement.setAttribute("data-theme","light")</script><script defer src=/js/header.7a2a109ec3782c57bad0332b662f8a5f41765505936b69868eb8bd5241de9daf23c388e82ca1831f6d09935013dcb9f71bfa7face3975880c1076028b7b0a6e1.js integrity="sha512-eioQnsN4LFe60DMrZi+KX0F2VQWTa2mGjri9UkHena8jw4joLKGDH20Jk1AT3Ln3G/p/rOOXWIDBB2Aot7Cm4Q=="></script>
<script defer src=/js/builtin-copy.56e07a74dd440b068ab36af35542ed8960865686c19fb809f38436877ac081570612cc8a913650b0c0e3073a336680c5df960e73bf7b1de83dc6aa996f2db858.js integrity="sha512-VuB6dN1ECwaKs2rzVULtiWCGVobBn7gJ84Q2h3rAgVcGEsyKkTZQsMDjBzozZoDF35YOc797Heg9xqqZby24WA=="></script>
<script defer src=/js/search-zh-cn.677e05c714f837051483647d736c45051126c22a2696ca5f981b59da962d48962f3ea71150f559ba84884fd1aadf1c7aadce55bb31a3e5b75c0f173b763c109a.js integrity="sha512-Z34FxxT4NwUUg2R9c2xFBREmwiomlspfmBtZ2pYtSJYvPqcRUPVZuoSIT9Gq3xx6rc5VuzGj5bdcDxc7djwQmg=="></script></head><body><main><header><div class=brand><div id=sidebar_btn><svg id="menu_icon" width="26" height="26" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></svg></div><div><a href=/>zznQ🎈</a></div></div><div class=toolbox><div id=theme_tool><svg id="dark_mode_btn" class="hidden toolbox-btn" width="18" height="18" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></svg><svg id="light_mode_btn" class="hidden toolbox-btn" width="18" height="18" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></svg></div><div id=search_tool><svg id="search_btn" class="toolbox-btn" width="18" height="18" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg></svg><div id=search_menu_wrapper class=hidden><div id=search_menu><div id=search_menu_toolbar><div id=search_menu_input_wrapper><input id=search_menu_input type=text placeholder="Search Posts"></div><div id=search_menu_close_btn><svg width="18" height="18" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></svg></div></div><div id=search_menu_results></div></div></div></div></div></header><nav id=navbar class=pure-menu><ul class=pure-menu-list><li class="navbar-item pure-menu-item insection"><a href=/posts/ class=pure-menu-link>文章</a></li><li class="navbar-item pure-menu-item"><a href=/categories/ class=pure-menu-link>分类</a></li><li class="navbar-item pure-menu-item"><a href=/tags/ class=pure-menu-link>标签</a></li></ul></nav><div id=sidebar_canvas_overlay class=hidden></div><div id=sidebar class=close><ul><li><a href=/posts/>文章</a></li><li><a href=/categories/>分类</a></li><li><a href=/tags/>标签</a></li></ul></div><div id=content class=content-margin><details class=collapsible-menu-wrapper><summary class=collapsible-menu-type><span>Table of contents</span></summary><div class=collapsible-menu><nav id=TableOfContents><ul><li><a href=#如何能通过静态的方式获取到-key-呢>如何能通过静态的方式获取到 key 呢？</a></li></ul></nav></div></details><div class=content-margin><article class=line-numbers><p>突然想解密下 WeChat 本地聊天数据库 ，这些 <code>msg_*.db</code> 文件一般存在 <code>~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application\ Support/com.tencent.xinWeChat/2.*******/123812fsdhg1232333sd/Message/</code> 目录下</p><p>google 发现一个教程：https://github.com/allen1881996/WeChat-Data-Analysis 测试后发现这个操作是可行的。大概步骤如下：通过 lldb 动态调试对 <code>sqlite3_key</code> 函数断点后再读取 $rsi 寄存器的值，进行简单拼接即得到了 sqlite3 raw-key。</p><p>但是心中出现了两个疑问：</p><ol><li>为什么是 <code>sqlite3_key</code>?</li></ol><p>Tencent有个开源项目 <a href=https://github.com/Tencent/wcdb>wcdb</a> 是基于SQLite的，加密使用的是开源的 <a href=https://github.com/sqlcipher/sqlcipher>SQLCipher</a> <code>sqlite3_key</code> 函数就是设置加密数据库的。wcdb 将其封装在了 <code>setCipherKey</code> 方法下。</p><ol start=2><li><code>memory read --size 1 --format x --count 32 $rsi</code> 是啥意思？</li></ol><p>x86-64 中函数调用时的参数存储如下寄存器中: <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, <code>%r9</code> 六个寄存器用于存储函数调用时的6个参数（如果有6个或6个以上参数的话）。</p><p><code>%rsi</code> 寄存器存储的为第二个参数，即对应 <code>int sqlite3_key(sqlite3 *db, const void *pKey, int nKey);</code> 中 key 。</p><hr><h2 id=如何能通过静态的方式获取到-key-呢>如何能通过静态的方式获取到 key 呢？</h2><p>根据 <code>WCDB</code> 的线索继续摸索，找到在哪里执行 <code>setCipherKey</code></p><p>摸索 wcdb 的文档发现<a href=https://github.com/Tencent/wcdb/wiki/iOS-macOS%e4%bd%bf%e7%94%a8%e6%95%99%e7%a8%8b#%E5%8A%A0%E5%AF%86>加密</a>：</p><pre tabindex=0><code>WCTDatabase *database = [[WCTDatabase alloc] initWithPath:path];
NSData *password = [@&#34;MyPassword&#34; dataUsingEncoding:NSASCIIStringEncoding];
[database setCipherKey:password];
</code></pre><p>在 <code>hopper Disassembler</code> 中搜索 setCipherKey 并没啥发现，只能换个思路在 dump 的头文件搜 <code>WCTDatabase</code> 发现很多需要存储的<code>*DB</code>类中都有个 <code>WCTDatabase *m_db;</code> 在往下翻 <code>- (BOOL)setupDB;</code> 这一看就是用来初始化数据库。</p><p>找到 <code>MessageDB.setupDB</code> 中密钥是从 <code>[WCDBHelper CipherKey]</code> 得到的，下面贴个伪代码：</p><pre tabindex=0><code>----WCDBHelper CipherKey----
+(void *)CipherKey {
    r14 = [[MMServiceCenter defaultCenter] retain];
    rax = [AccountStorage class];
    rax = [r14 getService:rax];
    rax = [rax retain];
    r13 = rax;
    rax = [rax GetDBEncryptInfo];
    rax = [rax retain];
    r15 = [[rax m_dbEncryptKey] retain];
</code></pre><p>简化下：[[AccountStorage GetDBEncryptInfo] m_dbEncryptKey]</p><p><code>AccountStorage</code> 中有个 init 方法：</p><p>db setting 文件路径：</p><pre tabindex=0><code>rax = [PathUtility GetAccountSettingDbPath];
rax = [rax retain];
rcx = *ivar_offset(m_dbEncryptInfoPath);
</code></pre><p>使用 PBCoder 从文件解码 DBEncryptInfo</p><pre tabindex=0><code>rax = [PBCoder decodeObjectOfClass:[DBEncryptInfo class] fromFile:r14-&gt;m_dbEncryptInfoPath];
</code></pre><p>pbcoding 是啥？</p><p><a href=https://github.com/Tencent/MMKV/issues/42#issuecomment-424976201>https://github.com/Tencent/MMKV/issues/42#issuecomment-424976201</a> <code>use protobuf protocol to archive/unarchive object.</code></p><p>从此回答中知道 pbcoding 是基于 protobuf 进行归档对象的。</p><p>hook <code>[PathUtility GetAccountSettingDbPath]</code> 找到文件为 <code>~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application\ Support/com.tencent.xinWeChat/2.***/123****1230000/Account/setting_db.data</code></p><p><code>protoc --decode_raw &lt; setting_db.data</code> 有三个属性，其中一个是时间戳。</p><p>看了看 <code>PBCoder decodeOneObject</code> 伪代码研究了好一会儿，还是不知道如何从这中解出数据库密码</p><hr><p>粗糙的记录下，短短的流程，却研究了两天。。。</p></article><script src=https://utteranc.es/client.js repo=Buzz2d0/zznq issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer><article>Copyright © 2019-2022 by zznq</article></footer></main></body></html>