<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>clang on zznQ</title><link>https://zznq.imipy.com/tags/clang/</link><description>Recent content in clang on zznQ</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 10 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://zznq.imipy.com/tags/clang/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux ptrace机制初探</title><link>https://zznq.imipy.com/posts/linux-ptrace-learning/</link><pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate><guid>https://zznq.imipy.com/posts/linux-ptrace-learning/</guid><description>补充下基础知识 动态加载 动态加载Dynamic Loading：是一种程序运行机制，能让计算机程序在运行时（而不是编译时）装载库（或者其他二进制对象）到内存中，然后检索库中函数和变量的地址，并运行这些函数或访问这些变量，且能在不需要时将库从内存中卸载。
linux下的/proc虚拟文件系统 Linux 内核提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。
/proc/&amp;lt;PID&amp;gt;/status / /proc/&amp;lt;PID&amp;gt;/stat： 查看进程信息 /proc/&amp;lt;PID&amp;gt;/maps：进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表 /proc/self/maps： 当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。 什么是 Ptrace？ 通过使用 ptrace（名称是 &amp;ldquo;process trace&amp;rdquo; 的缩写），一个进程可以控制另一个进程，从而使控制器能够检查和操纵目标的内部状态。
linux ptrace 函数提供了许多有用的调试操作：
PTRACE_ATTACH 允许一个进程将自身附加到另一个进程进行调试，从而暂停远程进程。 PTRACE_PEEKTEXT 允许从另一个进程地址空间读取内存。 PTRACE_POKETEXT 允许将内存写入另一个进程地址空间。 PTRACE_GETREGS 从进程中读取当前的处理器寄存器集。 PTRACE_SETREGS 写入进程的当前处理器寄存器集。 PTRACE_CONT 恢复附加进程的执行。 PTRACE_DETACH 是重新启动操作；它要求目标进程处于 ptrace-stop 中。 函数签名：
long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); 🌰 （Linux ubuntu 4.15.0-112-generic x86_64）:
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/wait.h&amp;gt;#include &amp;lt;sys/ptrace.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/user.h&amp;gt; int main(int argc, char **argv) { int child_pid; child_pid = fork(); if (child_pid == 0) { // `PTRACE_TRACEME` 本进程将被其父进程跟踪(此时剩下的`pid、addr、data`参数都没有实际意义可以全部为 0)。 ptrace(PTRACE_TRACEME, 0, 0, 0); execl(&amp;#34;/bin/ls&amp;#34;,&amp;#34;ls&amp;#34;,NULL); //执行系统调用 } else { struct user_regs_struct regs; wait(NULL); printf(&amp;#34;child process was stopped .</description></item></channel></rss>