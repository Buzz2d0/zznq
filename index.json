[{"content":"在破解Bartender4后没多久躁动地心又开始了这次就尝试破解macOS下的Typora，顺便记录一下。\n搜索相关文章看到成功破解 Win、Linux(Electron)的文章以及工具： https://blog.shi1011.cn/rev/1891 https://github.com/Mas0nShi/typoraCracker 文章中分析（win｜linux）addLicense 流程如下，macOS 上使用原生 webkit 开发，估计思路差不多：\n直接打开 Hopper 分析搜索 License 找到了 LicenseManager 类：\n看到一个关键字为 activate 的方法，签名如下：\n/* @class LicenseManager */ -(void)activate:(void *)arg2 with:(void *)arg3 force:(char)arg4 callback:(void *)arg5 {  /* - arg2 -\u0026gt; email - arg3 -\u0026gt; license - arg4 -\u0026gt; force - arg5 -\u0026gt; callback */ 分析 LicenseManager.activate 其方法流程：\n但是我不知道传入的 callback 是什么，为了搞清楚整个流程，想使用 firda 来打印下activate传入的参数：\n$ frida-trace -i \u0026#34;activate*\u0026#34; Typora Attaching... [1] 4229 killed frida-trace -i \u0026#34;activate*\u0026#34; Typora 进程直接被杀掉了 emmm 算逑！继续静态分析吧。\n（win｜linux） addLicense 流程中的最后一步出现的 decrypt关键字，根据这个关键字搜索到了核心的加解密 Crypto 类：\n以及\n/* @class LicenseManager */ -(char)verifySig:(void *)arg2 { 我猜测 callback 就是判断 response，将内容解密再去验证 license 成功后调用 writeLicenseInfo。\n那破解的思路就很清晰了：\n  修改 [LicenseManager quickValidateLicense]、[Crypto verify] [LicenseManager verifySig] 不去校验返回 true。\n  移除 sendPost 中网络请求的部分后写入证书。\n  汇编太难啦(菜是原罪)，修改之后不是奔溃就是hang住（程序hang着的原因可能是前端传入了事件等待 callback 运行完成），就在我快要放弃的时候看到52pojie上一篇破解 1.0 版本的文章（感谢国光师傅群里的热心师傅）：修改[LicenseManager hasLicense] 返回为true 。\n其实这个方法我之前也试过了，显示已经被激活： 修改系统时间使其到期，Typora软件还能用，点开Typora-\u0026gt;我的许可证后只能退出： 文章中的思路是hook showLicense 让其弹出其他窗口或者什么不做。\n那我就用这种方法吧，又不是不能用～🤪。\n 编写一个dylib hook [LicenseManager showLicense]，hasLicense 我已经使用 Hopper 修改过了。\n打开 XCode 创建 macOS-Libray：\n新建 main.m文件：\n#import \u0026lt;Foundation/Foundation.h\u0026gt; #include \u0026lt;Cocoa/Cocoa.h\u0026gt;#import \u0026lt;objc/runtime.h\u0026gt; #import \u0026#34;hookHelper.h\u0026#34;  @interface NSObject (LicenseManager) + (void) hookLicenseManager; @end  @implementation NSObject (LicenseManager) - (void)hook_showLicense:(char)arg2 {  NSString *message = @\u0026#34;zznQ\u0026#34;;  NSAlert *alert = [NSAlert new];  [alert addButtonWithTitle:@\u0026#34;OK\u0026#34;];  [alert setMessageText:message];  [alert setAlertStyle:NSAlertStyleCritical];  [alert runModal]; }  + (void) hookLicenseManager {  NSLog(@\u0026#34;in hookLicenseManager\u0026#34;);  hookMethod(objc_getClass(\u0026#34;LicenseManager\u0026#34;),  @selector(showLicense:),  [self class],  @selector(hook_showLicense:)); } @end  static void __attribute__((constructor)) initialize(void) {  NSLog(@\u0026#34;hook typora!!!\u0026#34;);  [NSObject hookLicenseManager]; } hookHelper.h 的 hookMethod 实现如下：\nvoid hookMethod(Class originalClass, SEL originalSelector, Class swizzledClass, SEL swizzledSelector){  Method originalMethod = class_getInstanceMethod(originalClass, originalSelector);  Method swizzledMethod = class_getInstanceMethod(swizzledClass, swizzledSelector);  if (originalMethod \u0026amp;\u0026amp; swizzledMethod){  method_exchangeImplementations(originalMethod, swizzledMethod);  } } 在M1机器上记得将 build active architecture only 参数改为 No：\n我使用Hopper 修改 Typora 后导出 Binary 为 x86_64 ，这里 dylib 也要瘦身为 x86_64（如果不是fat binary 就跳过） lipo libtyporahook.dylib -thin x86_64 -output libtyporahook_x86_64.dylib\n将 libtyporahook_x86_64.dylib 和 Typora/Contents/MacOS/ 目录下和 Typora 可执行文件放在一起，运行insert_dylib --all-yes @executable_path/libtyporahook_x86_64.dylib Typora 就好了。\n ","permalink":"https://zznq.imipy.com/posts/failed-to-crack-typora/","title":"记录一次破解[macOS]Typora失败的经历"},{"content":"如何使用API主动触发？\n在 docs.github.com 中找到了手动触发的接口。\n  在Github Settings 处（即 https://github.com/settings/tokens ）申请Tokens，放置API header 中 Authorization: token {{your token}}\n  在仓库根目录下创建 .github/workflows/heartbeat.yml 文件：\n  name: HeartBeat  on:  workflow_dispatch:  inputs:  value:  description: \u0026#39;value\u0026#39;  required: false  jobs:  sync:  name: Build  runs-on: ubuntu-latest  steps:  - name: Test-on-01  run: | echo ${{ github.event.inputs.value }}  请求接口（以我的仓库为例）：  curl \\  -X POST \\  -H \u0026#34;Accept: application/vnd.github.v3+json\u0026#34; \\  -H \u0026#34;Authorization: token xxxxxxxxx\u0026#34; \\  https://api.github.com/repos/Buzz2d0/Buzz2d0/actions/workflows/heartbeat.yml/dispatches \\  -d \u0026#39;{\u0026#34;ref\u0026#34;:\u0026#34;main\u0026#34;,\u0026#34;inputs\u0026#34;:{\u0026#34;value\u0026#34;:\u0026#34;66\u0026#34;}}\u0026#39; 测试通过✅后，就试试在IOS快捷指令下完成更新心率推送吧：\n在IOS快捷指令中创建一个新的指令（如下图：\n之后可以在自动化中添加“开始或者结束任意体能训练时”触发这个快捷指令。\n除了上面的列出的部分，我完善了一些小细节，具体可以查看我的仓库 https://github.com/Buzz2d0/Buzz2d0\n","permalink":"https://zznq.imipy.com/posts/ios-push-heartbeats-to-github-with-actions/","title":"IOS快捷指令+Github Actions更新心率"},{"content":"突然想解密下 WeChat 本地聊天数据库 ，这些 msg_*.db 文件一般存在 ~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application\\ Support/com.tencent.xinWeChat/2.*******/123812fsdhg1232333sd/Message/ 目录下\ngoogle 发现一个教程：https://github.com/allen1881996/WeChat-Data-Analysis 测试后发现这个操作是可行的。大概步骤如下：通过 lldb 动态调试对 sqlite3_key 函数断点后再读取 $rsi 寄存器的值，进行简单拼接即得到了 sqlite3 raw-key。\n但是心中出现了两个疑问：\n 为什么是 sqlite3_key?  Tencent有个开源项目 wcdb 是基于SQLite的，加密使用的是开源的 SQLCipher sqlite3_key 函数就是设置加密数据库的。wcdb 将其封装在了 setCipherKey 方法下。\nmemory read --size 1 --format x --count 32 $rsi 是啥意思？  x86-64 中函数调用时的参数存储如下寄存器中: %rdi, %rsi, %rdx, %rcx, %r8, %r9 六个寄存器用于存储函数调用时的6个参数（如果有6个或6个以上参数的话）。\n%rsi 寄存器存储的为第二个参数，即对应 int sqlite3_key(sqlite3 *db, const void *pKey, int nKey); 中 key 。\n 如何能通过静态的方式获取到 key 呢？ 根据 WCDB 的线索继续摸索，找到在哪里执行 setCipherKey\n摸索 wcdb 的文档发现加密：\nWCTDatabase *database = [[WCTDatabase alloc] initWithPath:path]; NSData *password = [@\u0026#34;MyPassword\u0026#34; dataUsingEncoding:NSASCIIStringEncoding]; [database setCipherKey:password]; 在 hopper Disassembler 中搜索 setCipherKey 并没啥发现，只能换个思路在 dump 的头文件搜 WCTDatabase 发现很多需要存储的*DB类中都有个 WCTDatabase *m_db; 在往下翻 - (BOOL)setupDB; 这一看就是用来初始化数据库。\n找到 MessageDB.setupDB 中密钥是从 [WCDBHelper CipherKey] 得到的，下面贴个伪代码：\n----WCDBHelper CipherKey---- +(void *)CipherKey { r14 = [[MMServiceCenter defaultCenter] retain]; rax = [AccountStorage class]; rax = [r14 getService:rax]; rax = [rax retain]; r13 = rax; rax = [rax GetDBEncryptInfo]; rax = [rax retain]; r15 = [[rax m_dbEncryptKey] retain]; 简化下：[[AccountStorage GetDBEncryptInfo] m_dbEncryptKey]\nAccountStorage 中有个 init 方法：\ndb setting 文件路径：\nrax = [PathUtility GetAccountSettingDbPath]; rax = [rax retain]; rcx = *ivar_offset(m_dbEncryptInfoPath); 使用 PBCoder 从文件解码 DBEncryptInfo\nrax = [PBCoder decodeObjectOfClass:[DBEncryptInfo class] fromFile:r14-\u0026gt;m_dbEncryptInfoPath]; pbcoding 是啥？\nhttps://github.com/Tencent/MMKV/issues/42#issuecomment-424976201 use protobuf protocol to archive/unarchive object.\n从此回答中知道 pbcoding 是基于 protobuf 进行归档对象的。\nhook [PathUtility GetAccountSettingDbPath] 找到文件为 ~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application\\ Support/com.tencent.xinWeChat/2.***/123****1230000/Account/setting_db.data\nprotoc --decode_raw \u0026lt; setting_db.data 有三个属性，其中一个是时间戳。\n看了看 PBCoder decodeOneObject 伪代码研究了好一会儿，还是不知道如何从这中解出数据库密码\n 粗糙的记录下，短短的流程，却研究了两天。。。\n","permalink":"https://zznq.imipy.com/posts/wechat-sqlite-key/","title":"逆向获取 MacOS WeChat App 聊天数据库密钥小记"},{"content":"简单记录下Golang web代码审计。\nSQLI \u0026ldquo;database/sql\u0026rdquo; 只是一个SQL数据库的通用接口，必须要与数据库驱动程序一起使用。\n支持的数据库驱动列表：https://github.com/golang/go/wiki/SQLDrivers\nMySQL star 最多的 MySQL 驱动为github.com/go-sql-driver/mysql，看下 connection.go 文件中的两个主要函数： Query(query string, args []driver.Value) 和 Exec(query string, args []driver.Value)，如何过滤参数的。\n通过判断 len(args) 长度，区分纯文本模式还是插值模式；插值模式时进入 interpolateParams() 函数过滤参数\n遍历 args 通过类型断言分别进行参数处理，并在 escapeBytesBackslash(buf, v []byte) []byte 函数中又对每个字符进行检查\n贴下代码：\n// https://github.com/go-sql-driver/mysql/blob/b36cd86ebcb680d317f962679780f5877a0b91e1/connection.go#L198  func (mc *mysqlConn) interpolateParams(query string, args []driver.Value) (string, error) { \t// Number of ? should be same to len(args) \tif strings.Count(query, \u0026#34;?\u0026#34;) != len(args) { \treturn \u0026#34;\u0026#34;, driver.ErrSkip \t}  ... \tbuf, err := mc.buf.takeCompleteBuffer()  ... \tfor i := 0; i \u0026lt; len(query); i++ { \t... \tswitch v := arg.(type) { \tcase int64: \tbuf = strconv.AppendInt(buf, v, 10) \tcase uint64: \t// Handle uint64 explicitly because our custom ConvertValue emits unsigned values \tbuf = strconv.AppendUint(buf, v, 10) \tcase float64: \tbuf = strconv.AppendFloat(buf, v, \u0026#39;g\u0026#39;, -1, 64) \tcase bool: \tif v { \tbuf = append(buf, \u0026#39;1\u0026#39;) \t} else { \tbuf = append(buf, \u0026#39;0\u0026#39;) \t} \tcase time.Time: \tif v.IsZero() { \tbuf = append(buf, \u0026#34;\u0026#39;0000-00-00\u0026#39;\u0026#34;...) \t} else { \tbuf = append(buf, \u0026#39;\\\u0026#39;\u0026#39;) \tbuf, err = appendDateTime(buf, v.In(mc.cfg.Loc)) \tif err != nil { \treturn \u0026#34;\u0026#34;, err \t} \tbuf = append(buf, \u0026#39;\\\u0026#39;\u0026#39;) \t} \tcase json.RawMessage: \tbuf = append(buf, \u0026#39;\\\u0026#39;\u0026#39;) \tif mc.status\u0026amp;statusNoBackslashEscapes == 0 { \tbuf = escapeBytesBackslash(buf, v) \t} else { \tbuf = escapeBytesQuotes(buf, v) \t} \tbuf = append(buf, \u0026#39;\\\u0026#39;\u0026#39;) \tcase []byte: \tif v == nil { \tbuf = append(buf, \u0026#34;NULL\u0026#34;...) \t} else { \tbuf = append(buf, \u0026#34;_binary\u0026#39;\u0026#34;...) \tif mc.status\u0026amp;statusNoBackslashEscapes == 0 { \tbuf = escapeBytesBackslash(buf, v) \t} else { \tbuf = escapeBytesQuotes(buf, v) \t} \tbuf = append(buf, \u0026#39;\\\u0026#39;\u0026#39;) \t} \tcase string: \tbuf = append(buf, \u0026#39;\\\u0026#39;\u0026#39;) \tif mc.status\u0026amp;statusNoBackslashEscapes == 0 { \tbuf = escapeStringBackslash(buf, v) \t} else { \tbuf = escapeStringQuotes(buf, v) \t} \tbuf = append(buf, \u0026#39;\\\u0026#39;\u0026#39;) \tdefault: \treturn \u0026#34;\u0026#34;, driver.ErrSkip \t}  \tif len(buf)+4 \u0026gt; mc.maxAllowedPacket { \treturn \u0026#34;\u0026#34;, driver.ErrSkip \t} \t} \treturn string(buf), nil }  ... // https://github.com/go-sql-driver/mysql/blob/b36cd86ebcb680d317f962679780f5877a0b91e1/utils.go#L692 func escapeStringBackslash(buf []byte, v string) []byte { \tpos := len(buf) \tbuf = reserveBuffer(buf, len(v)*2)  \tfor i := 0; i \u0026lt; len(v); i++ { \tc := v[i] \tswitch c { \tcase \u0026#39;\\x00\u0026#39;: \tbuf[pos] = \u0026#39;\\\\\u0026#39; \tbuf[pos+1] = \u0026#39;0\u0026#39; \tpos += 2 \tcase \u0026#39;\\n\u0026#39;: \tbuf[pos] = \u0026#39;\\\\\u0026#39; \tbuf[pos+1] = \u0026#39;n\u0026#39; \tpos += 2 \tcase \u0026#39;\\r\u0026#39;: \tbuf[pos] = \u0026#39;\\\\\u0026#39; \tbuf[pos+1] = \u0026#39;r\u0026#39; \tpos += 2 \tcase \u0026#39;\\x1a\u0026#39;: \tbuf[pos] = \u0026#39;\\\\\u0026#39; \tbuf[pos+1] = \u0026#39;Z\u0026#39; \tpos += 2 \tcase \u0026#39;\\\u0026#39;\u0026#39;: \tbuf[pos] = \u0026#39;\\\\\u0026#39; \tbuf[pos+1] = \u0026#39;\\\u0026#39;\u0026#39; \tpos += 2 \tcase \u0026#39;\u0026#34;\u0026#39;: \tbuf[pos] = \u0026#39;\\\\\u0026#39; \tbuf[pos+1] = \u0026#39;\u0026#34;\u0026#39; \tpos += 2 \tcase \u0026#39;\\\\\u0026#39;: \tbuf[pos] = \u0026#39;\\\\\u0026#39; \tbuf[pos+1] = \u0026#39;\\\\\u0026#39; \tpos += 2 \tdefault: \tbuf[pos] = c \tpos++ \t} \t}  \treturn buf[:pos] } 所以使用 插值模式 规避大多数 SQL 注入，禁止使用传入的参数来拼接 SQL 语句。\n如果你使用 gorm 请注意 https://gorm.io/zh_CN/docs/security.html 列出的函数，使用插值模式或者检测过滤用户输入的参数。\nXSS 推荐阅读这片文章 https://tech.meituan.com/2018/09/27/fe-security.html\n从 golang 后端的角度来说，清楚知道数据最后落在前端位置并做好相对应转义规则。\nCSRF 推荐阅读这片文章 https://tech.meituan.com/2018/10/11/fe-security-csrf.html\n目录遍历 gin package main  import ( \t\u0026#34;log\u0026#34;  \t\u0026#34;github.com/gin-gonic/gin\u0026#34; )  func main() { \tr := gin.Default() \tr.Static(\u0026#34;/uploads\u0026#34;, \u0026#34;./uploads\u0026#34;) \tif err := r.Run(\u0026#34;:8080\u0026#34;); err != nil { \tlog.Printf(\u0026#34;[Main] Gin engine error: %v\u0026#34;, err) \t} } 探究下是否存在目录遍历，翻阅代码 static 最后处理的是路由 /uploads/*filepath，获取文件名 file := c.Param(\u0026quot;filepath\u0026quot;) 并打开获取文件内容 f, err := fs.Open(file)\n贴下代码：\nr.StaticFS(\u0026#34;/uploads\u0026#34;, Dir(\u0026#34;./uploads\u0026#34;, false))  func (group *RouterGroup) StaticFS(relativePath string, fs http.FileSystem) IRoutes { \t... \thandler := group.createStaticHandler(relativePath, fs) \t// 路由规则 \turlPattern := path.Join(relativePath, \u0026#34;/*filepath\u0026#34;)  ... \tgroup.GET(urlPattern, handler) \tgroup.HEAD(urlPattern, handler)  ... } // createStaticHandler 生成静态文件处理路由 func (group *RouterGroup) createStaticHandler(relativePath string, fs http.FileSystem) HandlerFunc { \tabsolutePath := group.calculateAbsolutePath(relativePath) \tfileServer := http.StripPrefix(absolutePath, http.FileServer(fs)) \treturn func(c *Context) { \t... \tfile := c.Param(\u0026#34;filepath\u0026#34;)// 获取文件名 \t// Check if file exists and/or if we have permission to access it \tf, err := fs.Open(file) // 打开文件 \t... \tf.Close()  \tfileServer.ServeHTTP(c.Writer, c.Request) \t} } package http  type Dir string func (d Dir) Open(name string) (File, error) { \t... \tdir := string(d) \tif dir == \u0026#34;\u0026#34; { \tdir = \u0026#34;.\u0026#34; \t} \tfullName := filepath.Join(dir, filepath.FromSlash(path.Clean(\u0026#34;/\u0026#34;+name))) // `Clean()` 方法看： https://golang.org/pkg/path/#Clean。 \tf, err := os.Open(fullName) \t... \treturn f, nil } 在看看最后如何打开文件的 fullName := filepath.Join(dir, filepath.FromSlash(path.Clean(\u0026quot;/\u0026quot;+name))) 中的 path.Clean(\u0026quot;/\u0026quot;+name) name 前的 / 字符很关键，让一切没有希望。。。\n想要实现静态文件时，最好使用 golang http.Dir 处理传入文件参数，避免目录遍历。\n命令执行 代码执行 Jsonp劫持 Jsonp(JSON with Padding)是JSON的一种\u0026quot;使用模式\u0026quot;，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。设计出来就是为了解决同源策略的限制。\n写个简单 jsonp demo：\nserver 代码：\npackage main import ( \t\u0026#34;net/http\u0026#34; \t\u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { \tr := gin.Default() \tr.GET(\u0026#34;/jsonp\u0026#34;, func(c *gin.Context) { \tdata := map[string]interface{}{ \t\u0026#34;name\u0026#34;: \u0026#34;bar\u0026#34;, \t\u0026#34;desc\u0026#34;: \u0026#34;desc..\u0026#34;, \t} \tc.JSONP(http.StatusOK, data) \t}) \tr.Run(\u0026#34;:8080\u0026#34;) } client 代码：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \t\u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;title\u0026gt;Jsonp Test\u0026lt;/title\u0026gt;  \u0026lt;script\u0026gt;  log = function (data) {  alert(data.name);  console.log(data.desc);  };  \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \t\u0026lt;!-- script --\u0026gt;  \u0026lt;script src=\u0026#34;http://localhost:8080/jsonp?callback=log\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \t\u0026lt;!-- jquery --\u0026gt; \t\u0026lt;script\u0026gt;  $(document).ready(function () {  $.ajax({  type: \u0026#34;get\u0026#34;,  url: \u0026#34;http://localhost:8080/jsonp\u0026#34;,  dataType: \u0026#34;jsonp\u0026#34;,  jsonp: \u0026#34;callback\u0026#34;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)  jsonpCallback: \u0026#34;log\u0026#34;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写\u0026#34;?\u0026#34;，jQuery会自动为你处理数据  success: function (data) {},  error: function () {alert(\u0026#39;fail\u0026#39;);}  });  });  \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如何自动化检测？ a-tour-of-xray这篇博客中已经详细介绍了如何手工挖掘\n在“判断是否包含敏感信息”的部分也不是采取简单正则匹配发现敏感信息而是采用AST语义分析。我在此 jweny - check_jsonp_based_on_ast 基础做了深度优化，真正的能检测类似如下js语句：\ncallback({\u0026#34;data\u0026#34;: {username:\u0026#34;jweny\u0026#34;}}); callback({\u0026#34;data\u0026#34;: {a:\u0026#34;jweny\u0026#34;,test:0, args:[\u0026#34;123\u0026#34;, 1,{username:\u0026#34;xx\u0026#34;}]}}); callback([{\u0026#34;info\u0026#34;: {\u0026#34;username\u0026#34;: \u0026#34;jweny\u0026#34;}}]) cb(\u0026#39; {\u0026#34;username\u0026#34;:\u0026#34;jweny\u0026#34;} \u0026#39;) /*aa*/ window.cb({\u0026#34;username\u0026#34;:\u0026#34;jweny\u0026#34;}) /*aa*/ window.cb \u0026amp;\u0026amp; window.cb({\u0026#34;username\u0026#34;:\u0026#34;jweny\u0026#34;}) /*aa*/ cb \u0026amp;\u0026amp; cb({\u0026#34;username\u0026#34;:\u0026#34;jweny\u0026#34;}) a={\u0026#34;username\u0026#34;: \u0026#34;jweny\u0026#34;}; cb({\u0026#34;s\u0026#34;: a}); a={\u0026#34;username\u0026#34;: \u0026#34;jweny\u0026#34;}; cb(a); 相关源码贴在此：https://github.com/Buzz2d0/taser/blob/main/probe/jsonp.go\n","permalink":"https://zznq.imipy.com/posts/golang-web-audit/","title":"golang web audit 小记"},{"content":"我尝试用 golang 编写一些核心代码，再利用 cgo 的特性将其打包成 dylib 文件，以便于我在objc 中调用（因为我 objc 写的很烂）。\n先写个很简单的 cgo 程序 main.go ：\npackage main  //void HelloWorld(); import \u0026#34;C\u0026#34; import \u0026#34;fmt\u0026#34;  //export HelloWorld func HelloWorld() { \tfmt.Println(\u0026#34;Hello World!!!\u0026#34;) }  func main() {} 代码中有几个地方需要注意下：\n import \u0026quot;C\u0026quot; 语句则表示开启了CGO特性 //export HelloWorld CGO 指令将其导出为C语言函数  编译为dylib动态库： $ go build -buildmode=c-shared--ldflags=\u0026quot;-w -s\u0026quot; -o cgodemo.dylib cgoDemo/main.go\n查看下文件信息：\n$ file cgodemo.dylib cgodemo.dylib: Mach-O 64-bit dynamically linked shared library x86_64 $ otool -L cgodemo.dylib cgodemo.dylib:  cgodemo.dylib (compatibility version 0.0.0, current version 0.0.0)  /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1292.100.5) 调用下动态库测试下 main.c ：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;dlfcn.h\u0026gt; int main() {  char *so_path = \u0026#34;./cgodemo.dylib\u0026#34;;  void *lib = dlopen(so_path, RTLD_LAZY);  void (*HelloWorld)();  HelloWorld = dlsym(lib, \u0026#34;HelloWorld\u0026#34;);  HelloWorld(); } 测试：\n$ clang main.c -o main $ ./main Hello World!!! amazing!\n 在 objc 下尝试加载动态库：\n#import \u0026lt;Foundation/Foundation.h\u0026gt; #include \u0026#34;dlfcn.h\u0026#34; int main(int argc, const char * argv[]) {  @autoreleasepool {  void *lib = dlopen(\u0026#34;../cgodemo.dylib\u0026#34;, RTLD_LAZY);  if (NULL != lib){  NSLog(@\u0026#34;not found dylib file...\u0026#34;);  return 1;  }  void (*HelloWorld)(void) = dlsym(lib, \u0026#34;HelloWorld\u0026#34;);  if (NULL != lib){  HelloWorld();  }else{  NSLog(@\u0026#34;not found HelloWorld()\u0026#34;);  }  dlclose(lib);  }  return 0; } 然而并非一番风顺，打印 not found HelloWorld()，找不到 HelloWorld 函数，google 了好久也没排查出原因，路过的您如果知道咋解决麻烦🙏告诉我一下😁。\n 放弃？是不可能的，这辈子都不可能\n排查问题时发现了 mobile 工具：https://github.com/golang/mobile ，可以在 Java \u0026amp; Objc 中调用 golang, 相关文档在 https://github.com/golang/go/wiki/Mobile 。\n虽然说了 gobuild 并不支持单独使用，但是 $ gomobile bind -target=ios golang.org/x/mobile/example/bind/hello 可以将 hello package 生成 Hello.framework, 然后就可以在 objc 中直接调用了 🐂🍺\n所以首先解决下如何修改参数让其可以编译为 macos 平台的 Framework，google 到一个 https://github.com/golang/go/issues/31258 ，他是这么解决的：\n// cmd/gomobile/env.go ... case \u0026#34;386\u0026#34;, \u0026#34;amd64\u0026#34;: \tclang, cflags, err = envClang(\u0026#34;iphonesimulator\u0026#34;) \tcflags += \u0026#34; -mios-simulator-version-min=\u0026#34; + buildIOSVersion // 修该为： \tclang, cflags, err = envClang(\u0026#34;macosx\u0026#34;) \tcflags += \u0026#34; -mmacosx-version-min=10.11\u0026#34; ... 我 fork 下来修改并提交了 https://github.com/Buzz2d0/mobile ，在测试发现这里版本-mmacosx-version-min=10.11 可以根据自己系统版本来决定，我用的 bigsur 11.3 就改为了 10.15 。\n 安装修改后的 gomobile\n$ git clone https://github.com/Buzz2d0/mobile $ cd mobile $ go build golang.org/x/mobile/cmd/gomobile $ gomobile init 敲个测试代码 lib/lib.go：\npackage lib  import \u0026#34;fmt\u0026#34;  func Greetings(name string) string { \treturn fmt.Sprintf(\u0026#34;Hello, %s!\u0026#34;, name) } 创建 Lib.framework ： $ ../mobile/gomobile bind -target=ios demo/lib\n把 Lib.framework 导入到 Xcode 中，具体操作：https://github.com/golang/go/wiki/Mobile#building-and-deploying-to-ios-1\nmain.m :\n#import \u0026lt;Foundation/Foundation.h\u0026gt; #import \u0026lt;objc/runtime.h\u0026gt; #import \u0026#34;Lib/Lib.h\u0026#34;  int main(int argc, const char * argv[]) {  @autoreleasepool {  NSString * str = LibGreetings(@\u0026#34;this is a golang function\u0026#34;);  NSLog(@\u0026#34;%@\u0026#34;, str);  }  return 0; } 编译运行 成功啦！\n","permalink":"https://zznq.imipy.com/posts/cgoobjc/","title":"cgo \u0026 objc"},{"content":"之前看到 Xray - 如何编写expression表达式 提到这个库 https://github.com/google/cel-spec\n正好工作方面也遇到这个需求了，就来简单的研究下，先看下相关资料：\n cel-spec 介绍 cel-go github cel-go 入门文档   cel 是建立 protocol 之上的。\n在 demo 项目下创建 fprint 包；并在其目录下创建 fprint.proto 文件\nsyntax = \u0026#34;proto3\u0026#34;;package fprint; // https://developers.google.com/protocol-buffers/docs/proto3#packages option go_package = \u0026#34;fprint/bp\u0026#34;; // golang package 包名 message Response { string url = 1; int32 status = 2 ; map\u0026lt;string, string\u0026gt; headers = 3; string content_type = 4; string title = 5; bytes body = 6; string md5 = 7;}使用 $ protoc --go_out=./ fprint/fprint.proto 生成 go 代码\n创建 cel.go 文件，添加下自己定义函数等，目录结构如下：\ndemo ├── fprint │ ├── bp │ │ └── fprint.pb.go │ ├── cel.go │ ├── cel_test.go │ └── fprint.proto cel.go:\npackage fprint  import ( \t\u0026#34;bytes\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;regexp\u0026#34;  \t\u0026#34;github.com/google/cel-go/cel\u0026#34; \t\u0026#34;github.com/google/cel-go/checker/decls\u0026#34; \t\u0026#34;github.com/google/cel-go/common/types\u0026#34; \t\u0026#34;github.com/google/cel-go/common/types/ref\u0026#34; \t\u0026#34;github.com/google/cel-go/interpreter/functions\u0026#34;  \t\u0026#34;demo/fprint/bp\u0026#34;  \texprpb \u0026#34;google.golang.org/genproto/googleapis/api/expr/v1alpha1\u0026#34; )  func NewEnv(f *fprintLib) (*cel.Env, error) { \treturn cel.NewEnv(cel.Lib(f)) }  func Evaluate(env *cel.Env, expression string, params map[string]interface{}) (ref.Val, error) { \tast, iss := env.Compile(expression) \tif iss.Err() != nil { \tlog.Println(\u0026#34;compile error\u0026#34;) \treturn nil, iss.Err() \t}  \tprg, err := env.Program(ast) \tif err != nil { \tlog.Println(\u0026#34;Program creation error\u0026#34;) \treturn nil, err \t}  \tout, _, err := prg.Eval(params) \tif err != nil { \tlog.Println(\u0026#34;Evaluation error\u0026#34;) \treturn nil, err \t} \treturn out, nil }  type fprintLib struct { \tenvOptions []cel.EnvOption \tprogramOptions []cel.ProgramOption }  func NewEnvOption() *fprintLib { \tf := \u0026amp;fprintLib{} \tf.envOptions = []cel.EnvOption{  // 注册 response 类型 \tcel.Container(\u0026#34;fprint.Response\u0026#34;), \tcel.Types( \t\u0026amp;bp.Response{}, \t), \tcel.Declarations( \tdecls.NewIdent(\u0026#34;response\u0026#34;, decls.NewObjectType(\u0026#34;fprint.Response\u0026#34;), nil), \t),  // 定义方法、函数等 \tcel.Declarations( \tdecls.NewFunction(\u0026#34;bcontains\u0026#34;, \tdecls.NewInstanceOverload(\u0026#34;bytes_bcontains_bytes\u0026#34;, \t[]*exprpb.Type{decls.Bytes, decls.Bytes}, \tdecls.Bool)), \tdecls.NewFunction(\u0026#34;regexp\u0026#34;, \tdecls.NewOverload(\u0026#34;regexp_string_string\u0026#34;, \t[]*exprpb.Type{decls.String, decls.String}, \tdecls.Bool)), \tdecls.NewFunction(\u0026#34;version\u0026#34;, \tdecls.NewOverload(\u0026#34;version_string_string_int\u0026#34;, \t[]*exprpb.Type{decls.String, decls.String, decls.Int}, \tdecls.String)), \t), \t} \tf.programOptions = []cel.ProgramOption{  cel.Functions(  // bytes_bcontains_bytes 的实现 \t\u0026amp;functions.Overload{ \tOperator: \u0026#34;bytes_bcontains_bytes\u0026#34;, \tBinary: func(lhs ref.Val, rhs ref.Val) ref.Val { \tv1, ok := lhs.(types.Bytes) \tif !ok { \treturn types.ValOrErr(lhs, \u0026#34;unexpected type \u0026#39;%v\u0026#39; passed to bcontains\u0026#34;, lhs.Type()) \t} \tv2, ok := rhs.(types.Bytes) \tif !ok { \treturn types.ValOrErr(rhs, \u0026#34;unexpected type \u0026#39;%v\u0026#39; passed to bcontains\u0026#34;, rhs.Type()) \t} \treturn types.Bool(bytes.Contains(v1, v2)) \t}, \t},  // regexp_string_string 的实现 \t\u0026amp;functions.Overload{ \tOperator: \u0026#34;regexp_string_string\u0026#34;, \tBinary: func(arg1, arg2 ref.Val) ref.Val { \treg, ok := arg1.(types.String) \tif !ok { \treturn types.ValOrErr(arg1, \u0026#34;unexpected type \u0026#39;%v\u0026#39; passed to regexp\u0026#34;, arg1.Type()) \t} \tval, ok := arg2.(types.String) \tif !ok { \treturn types.ValOrErr(arg2, \u0026#34;unexpected type \u0026#39;%v\u0026#39; passed to regexp\u0026#34;, arg2.Type()) \t} \tmatched, err := regexp.MatchString(string(reg), string(val)) \tif err != nil { \treturn types.ValOrErr(arg2, \u0026#34;Wrong regular syntax \u0026#39;%v\u0026#39; passed to version\u0026#34;, arg2.Type()) \t} \treturn types.Bool(matched) \t}, \t},  // version_string_string_int 的实现 \t\u0026amp;functions.Overload{ \tOperator: \u0026#34;version_string_string_int\u0026#34;, \tFunction: func(values ...ref.Val) ref.Val { \tif len(values) != 3 { \treturn types.NewErr(\u0026#34;too many arguments to \u0026#39;substr\u0026#39;\u0026#34;) \t} \toffset, ok := values[2].(types.Int) \tif !ok { \treturn types.ValOrErr(values[2], \u0026#34;unexpected type \u0026#39;%v\u0026#39; passed to version\u0026#34;, values[2].Type()) \t} \tif offset \u0026lt; 0 { \toffset = 0 \t}  \treg, ok := values[0].(types.String) \tif !ok { \treturn types.ValOrErr(values[0], \u0026#34;unexpected type \u0026#39;%v\u0026#39; passed to version\u0026#34;, values[0].Type()) \t} \tval, ok := values[1].(types.String) \tif !ok { \treturn types.ValOrErr(values[1], \u0026#34;unexpected type \u0026#39;%v\u0026#39; passed to version\u0026#34;, values[1].Type()) \t} \tregx, err := regexp.Compile(string(reg)) \tif err != nil { \treturn types.ValOrErr(values[0], \u0026#34;Wrong regular syntax \u0026#39;%v\u0026#39; passed to version\u0026#34;, values[0].Type()) \t} \tvals := regx.FindStringSubmatch(string(val)) \tif len(vals) \u0026lt;= 0 { \treturn types.String(\u0026#34;\u0026#34;) \t} \toffset += 1 \tif int(offset) \u0026gt; len(vals) { \toffset = types.Int(len(vals) - 1) \t} \treturn types.String(vals[offset]) \t}, \t}, \t), \t} \treturn f }  // EnvOptions returns options for the standard CEL function declarations and macros. func (f *fprintLib) CompileOptions() []cel.EnvOption { \treturn f.envOptions }  // ProgramOptions returns function implementations for the standard CEL functions. func (f *fprintLib) ProgramOptions() []cel.ProgramOption { \treturn f.programOptions } 写个单元测试运行下，cel_test.go ：\npackage fprint  import ( \t\u0026#34;demo/fprint/bp\u0026#34; \t\u0026#34;testing\u0026#34; )  func TestFprint(t *testing.T) { \tflib := NewEnvOption() \tenv, err := NewEnv(flib) \tif err != nil { \tt.Fatal(err) \t} \tparams := map[string]interface{}{} \tparams[\u0026#34;response\u0026#34;] = \u0026amp;bp.Response{ \tUrl: \u0026#34;http://www.baidu.com\u0026#34;, \tStatus: 404, \tHeaders: map[string]string{ \t\u0026#34;server\u0026#34;: \u0026#34;nginx\u0026#34;, \t}, \tContentType: \u0026#34;application/json\u0026#34;, \tTitle: \u0026#34;this is a titleTest Bootstrap v0.1.1 test\u0026#34;, \tBody: []byte(\u0026#34;http.body\u0026#34;), \t}  \tout, err := Evaluate(env, `response.status == 200`, params) \tif err != nil { \tt.Fatal(err) \t} \tt.Log(\u0026#34;response.status == 200\u0026#34;, out)  \tout, err = Evaluate(env, `response.headers[\u0026#34;server\u0026#34;] == \u0026#34;nginx\u0026#34;`, params) \tif err != nil { \tt.Fatal(err) \t} \tt.Log(`response.headers[\u0026#34;server\u0026#34;] == \u0026#34;nginx\u0026#34;`, out)  \tout, err = Evaluate(env, `response.body.bcontains(b\u0026#34;body\u0026#34;)`, params) \tif err != nil { \tt.Fatal(err) \t} \tt.Log(`response.body.bcontains(b\u0026#34;body\u0026#34;)`, out)  \tout, err = Evaluate(env, `regexp(\u0026#34;(?im)bootstrap ([vV])?([0-9\\\\.]+)\u0026#34;, response.title)`, params) \tif err != nil { \tt.Fatal(err) \t} \tt.Log(`regexp(\u0026#34;(?im)bootstrap ([vV])?([0-9\\\\.]+)\u0026#34;, response.title)`, out)  \tout, err = Evaluate(env, `version(\u0026#34;(?im)bootstrap ([vV])?([0-9\\\\.]+)\u0026#34;, response.title, 1)`, params) \tif err != nil { \tt.Fatal(err) \t} \tt.Log(`version(\u0026#34;(?im)bootstrap ([vV])?([0-9\\\\.]+)\u0026#34;, response.title, 1)`, out) } ","permalink":"https://zznq.imipy.com/posts/cel-go-demo/","title":"cel-go 初探"},{"content":"查看包内容，在Resources 目录下找到 app.asar 文件\n解压 app.asar 文件\n$ npm install asar -g $ cd /Applications/AppName.app/Contents/Resources $ asar e app.asar appCore 进入到与app.asar.unpacked的同级目录下，不然会有如下错误：https://github.com/electron/asar/issues/37\n 解包之后目录如下\nls -lahrt total 8 drwxr-xr-x@ 64 staff 2.0K May 4 11:09 .. -rw-r--r-- 1 staff 984B May 4 11:09 package.json drwxr-xr-x 3 staff 96B May 4 11:09 dist drwxr-xr-x 5 staff 160B May 4 11:09 . drwxr-xr-x 166 staff 5.2K May 4 11:09 node_modules 源码在 dist/electron 下；一般这里的 js 都是经过混淆，逻辑需要进行具体的分析\u0026hellip;\nJS反混淆还是比较复杂繁琐的，现在能力有限，等之后遇到实际的需求时在研究下吧！\n 拖到chrome里面进行格式化 反混淆 js 代码 使用一些脚本 https://gist.github.com/Buzz2d0/776f8d1bb65732504775dd204ff9b303 AST  参考文章  使用 estools 辅助反混淆 Javascript  ","permalink":"https://zznq.imipy.com/posts/macos-electron-analysis/","title":"MacOS - Electron 应用分析小记"},{"content":"MacOS 下的 app 不是一个可执行文件而是一个 Application Bundle，而 Bundle 就是一个遵循特定结构的目录，包含 Info.plist、可执行文件、资源、Framworks 等内容，其中 Info.plist 和 Executable 是必要的。\n来看下 WeChat.app Bundle 的目录结构，先忽略 Framworks、Resources 等：\nWeChat.app ├── Contents │ └── MacOS │ └── WeChat │ └── Info.plist 了解关键文件信息 - 知彼知己 Info.plist 查看官网文档关于Info.plist 的介绍中，有一句很关键话：\n The way an app provides its metadata to the system is through the use of a special file called an information property list file, or Info.plist for short.\n 使用 plutil 查看 Info.plist 内容\n$ plutil -p Info.plist\n还可以将其转换为 xml1 binary1 json swift objc\n$ plutil -convert json Info.plist -o Info-plist.json\n ** MacOS 支持三种可执行文件的格式**\n 解释器脚本格式，这个就不用多说了，类似 ruby perl python 等。 Mach-O (Mach Object 的缩写)是 IOS/MacOS 下的原生可执行文件格式 通用二进制格式又称胖二进制格式（Fat Binary），是将多个 Mach-O 文件组合成一个多重架构的二进制文件。  通用二进制文件 使用 file 命令查看信息：\n$ file WeChat MacOS/WeChat: Mach-O 64-bit executable x86_64 这里仅支持 amd64，找个通用二进制格式的例子：\n$ file /usr/bin/python /usr/bin/python: Mach-O universal binary with 2 architectures: [x86_64:Mach-O 64-bit executable x86_64] [arm64e:Mach-O 64-bit executable arm64e] /usr/bin/python (for architecture x86_64):\tMach-O 64-bit executable x86_64 /usr/bin/python (for architecture arm64e):\tMach-O 64-bit executable arm64 系统提供了一个命令行工具 lipo 来操作通用二进制文件。它可以添加、提取、删除以及替换通用二进制文件中特定架构的二进制版本。 直接瘦身为某种架构的版本： $ lipo \u0026lt;Mach-O\u0026gt; -thin \u0026lt;架构名\u0026gt; -output \u0026lt;路径\u0026gt; 也可以合并多个架构： $ lipo -create \u0026lt;Mach-O1\u0026gt; \u0026lt;Mach-O2\u0026gt; -output \u0026lt;路径\u0026gt;\n通用二进制的“通用”不止针对可以直接运行的可执行程序，系统中的动态库dylib、静态库.a文件以及框架等都可以是通用二进制文件，对它们也可以同样使用lipo命令来进行管理。 可以在\u0026lt;mach-o/fat.h\u0026gt;文件中找到通用二进制文件格式的声明(📣: BigSur 下的SDK迁移到：/Library/Developer/CommandLineTools/SDKs/ 目录下了 )\n使用 otool 工具打印的 fat_header 信息：\n$ otool -f -V /usr/bin/python Fat headers fat_magic FAT_MAGIC nfat_arch 2 architecture x86_64 cputype CPU_TYPE_X86_64 cpusubtype CPU_SUBTYPE_X86_64_ALL capabilities 0x0 offset 16384 size 55984 align 2^14 (16384) architecture arm64e cputype CPU_TYPE_ARM64 cpusubtype CPU_SUBTYPE_ARM64E capabilities PTR_AUTH_VERSION USERSPACE 0 offset 81920 size 39344 align 2^14 (16384) 在 fat_arch 结构体往下就是具体的Mach-O文件格式了。\nMach-O 文件 Mach-O文件由头(Header)、装载指令(Load commands)和数据(Data)组成。我们可以通过MachOView软件进行查看。其中，最重要的组成部分就是Data。\n 这里简单了解下 Data: Data可以分为多个段(Segment), 每个段又可以分为多个节(Section)。\nsegment可以理解为一段连续的内存空间，拥有对应的读/写/执行权限。从逻辑角度来看，每个段内的节存储的数据都有类似的目的。如__TEXT 段内存储的有汇编源代码、字符串等，__DATA 段内存储非常量初始化变量等。从内存管理角度来看，每个段的大小被要求是页大小的倍数，也就是 4096B 的倍数。当程序加载时，就可以正好将一个段加载到一个页内。\n每个segment由一个或者多个section组成，section表示特定含义数据或者代码的集合(不需要页对齐)。在macOS中，通常约定segment的名称为双下划线加全大写字母(如__TEXT)，section的名称为双下划线加小写字母(如__text)。\n header header 结构定义在 “mach-o/loader.h” 文件中，针对32位与64位架构的cpu，分别使用了mach_header与mach_header_64结构体来描述Mach-O头部。\nstruct mach_header { \tuint32_t\tmagic;\t/* mach magic number identifier */ \tcpu_type_t\tcputype;\t/* cpu specifier */ \tcpu_subtype_t\tcpusubtype;\t/* machine specifier */ \tuint32_t\tfiletype;\t/* type of file */ \tuint32_t\tncmds;\t/* number of load commands */ \tuint32_t\tsizeofcmds;\t/* the size of all the load commands */ \tuint32_t\tflags;\t/* flags */ };  filetype 字段表示 Mach-O的具体文件类型，我这里主要关注：MH_EXECUTE、MH_DYLIB 类型。 ncmds 指明了Mach-O文件中加载命令（load commands）的数量。  使用 $ otool -h -V 查看 header 信息\n$ otool -h -V /usr/bin/python /usr/bin/python: Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC_64 X86_64 ALL 0x00 EXECUTE 18 1472 NOUNDEFS DYLDLINK TWOLEVEL PIE load command 在mach_header之后的是Load Command加载命令，这些加载命令在Mach-O文件加载解析时，被内核加载器或者动态链接器调用，基本的加载命令的数据结构如下：\nstruct load_command { \tuint32_t cmd;\t/* type of load command */ \tuint32_t cmdsize;\t/* total size of command in bytes */ };  cmd 字段代表当前加载命令的类型 cmdsize 字段代表当前加载命令的大小  加载命令类型的定义在 mach-o/loader.h 中，以 LC 为前缀的；所有的这些加载命令由系统内核加载器直接使用，或由动态链接器处理。其中几个常见的加载命令有LC_SEGMENT、LC_LOAD_DYLINKER、LC_LOAD_DYLIB、LC_MAIN、LC_CODE_SIGNATURE、LC_ENCRYPTION_INFO 等。\n这里重点关注下 dylib 的加载，当cmd类型时 LC_ID_DYLIB、LC_LOAD_DYLIB、LC_LOAD_WEAK_DYLIB与LC_REEXPORT_DYLIB 时，统一使用 dylib_command 结构体表示：\nstruct dylib_command { \tuint32_t\tcmd;\t/* LC_ID_DYLIB, LC_LOAD_{,WEAK_}DYLIB, LC_REEXPORT_DYLIB */ \tuint32_t\tcmdsize;\t/* includes pathname string */ \tstruct dylib\tdylib;\t/* the library identification */ }; struct dylib {  union lc_str name;\t/* library\u0026#39;s path name */  uint32_t timestamp;\t/* library\u0026#39;s build time stamp */  uint32_t current_version;\t/* library\u0026#39;s current version number */  uint32_t compatibility_version;\t/* library\u0026#39;s compatibility vers number*/ }; 看了这么多原理有些晕乎乎，写代码实操一下。\n 用 Xcode 创建一个 \u0026ldquo;InsertDemoApp\u0026rdquo; command程序\nmian.mm 文件内容:\n#import \u0026lt;Foundation/Foundation.h\u0026gt;  // Person @interface Person : NSObject @property (nonatomic) NSString *name; @property (nonatomic) NSNumber *age; - (NSString *)description; @end  @implementation Person - (NSString *)description {  return [NSString stringWithFormat:@\u0026#34;\u0026lt;%@: %@\u0026gt;\u0026#34;, self.name, self.age]; } @end   int main(int argc, const char * argv[]) {  @autoreleasepool {  NSLog(@\u0026#34;Hello, World!\u0026#34;);   Person *p = [[Person alloc] init];  [p setName:@\u0026#34;zznq\u0026#34;];  [p setAge:@10];   NSLog(@\u0026#34;person: %@\u0026#34;, p);  }  return 0; } 再用 Xcode 创建一个 \u0026ldquo;InsertLibTest\u0026rdquo; dylib程序 main.mm 文件内容：\n#import \u0026lt;Foundation/Foundation.h\u0026gt; #import \u0026lt;objc/runtime.h\u0026gt;  @interface NSObject (Person) + (void) hookPerson; @end  @implementation NSObject (Person) // hook person description - (NSString *) personDescription {  NSLog(@\u0026#34;in personDescription\u0026#34;);  return [self personDescription]; } + (void) hookPerson {  NSLog(@\u0026#34;in hookPerson\u0026#34;);   Method originalMethod = class_getInstanceMethod(objc_getClass(\u0026#34;Person\u0026#34;), @selector(description));  Method swizzledMethod = class_getInstanceMethod([self class], @selector(personDescription));  if (originalMethod \u0026amp;\u0026amp; swizzledMethod){  method_exchangeImplementations(originalMethod, swizzledMethod);  } } @end  static void __attribute__((constructor)) initialize(void) {  NSLog(@\u0026#34;hook common inject success!\u0026#34;);   [NSObject hookPerson]; } 编译之后使用 insert_dylib 将 libInsertLibTest.dylib 注入到 InsertDemoApp\n$ insert_dylib libInsertLibTest.dylib InsertDemoApp $ ./InsertDemoApp_patched 2021-05-09 17:47:02.123 InsertDemoApp_patched[28336:319241] hook common inject success! 2021-05-09 17:47:02.123 InsertDemoApp_patched[28336:319241] in hookPerson 2021-05-09 17:47:02.123 InsertDemoApp_patched[28336:319241] Hello, World! 2021-05-09 17:47:02.123 InsertDemoApp_patched[28336:319241] in personDescription 2021-05-09 17:47:02.123 InsertDemoApp_patched[28336:319241] in personDescription 2021-05-09 17:47:02.123 InsertDemoApp_patched[28336:319241] person: \u0026lt;zznq: 10\u0026gt; 已经成功加载了 libInsertLibTest.dylib 文件，hook 成功。\ninsert_dylib 的原理就是利用 load_command 加载 dylib；用 $ otool -l -V filename 并用 diff 对比两个文件后不同处：\n... --- \u0026lt; cmd LC_CODE_SIGNATURE \u0026lt; cmdsize 16 \u0026lt; dataoff 52432 \u0026lt; datasize 19168 --- \u0026gt; cmd LC_LOAD_DYLIB \u0026gt; cmdsize 48 \u0026gt; name libInsertLibTest.dylib (offset 24) \u0026gt; time stamp 0 Thu Jan 1 08:00:00 1970 \u0026gt; current version 0.0.0 \u0026gt; compatibility version 0.0.0 很明显移除了代码签名加载命令 LC_CODE_SIGNATURE 换成了加载 libInsertLibTest.dylib 的命令。\n 参考文章  About Bundles Bundle Structures Mach-O文件格式 - 非虫 深入浅出MachO Mach-O 文件格式探索 dylib浅析  ","permalink":"https://zznq.imipy.com/posts/macos-app-insert-dylib/","title":"MacOS App Insert dylib 小记"},{"content":"补充下基础知识 动态加载 动态加载Dynamic Loading：是一种程序运行机制，能让计算机程序在运行时（而不是编译时）装载库（或者其他二进制对象）到内存中，然后检索库中函数和变量的地址，并运行这些函数或访问这些变量，且能在不需要时将库从内存中卸载。\nlinux下的/proc虚拟文件系统 Linux 内核提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。\n /proc/\u0026lt;PID\u0026gt;/status / /proc/\u0026lt;PID\u0026gt;/stat： 查看进程信息 /proc/\u0026lt;PID\u0026gt;/maps：进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表 /proc/self/maps： 当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。  什么是 Ptrace？ 通过使用 ptrace（名称是 \u0026ldquo;process trace\u0026rdquo; 的缩写），一个进程可以控制另一个进程，从而使控制器能够检查和操纵目标的内部状态。\nlinux ptrace 函数提供了许多有用的调试操作：\n PTRACE_ATTACH 允许一个进程将自身附加到另一个进程进行调试，从而暂停远程进程。 PTRACE_PEEKTEXT 允许从另一个进程地址空间读取内存。 PTRACE_POKETEXT 允许将内存写入另一个进程地址空间。 PTRACE_GETREGS 从进程中读取当前的处理器寄存器集。 PTRACE_SETREGS 写入进程的当前处理器寄存器集。 PTRACE_CONT 恢复附加进程的执行。 PTRACE_DETACH 是重新启动操作；它要求目标进程处于 ptrace-stop 中。  函数签名：\nlong ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); 🌰 （Linux ubuntu 4.15.0-112-generic x86_64）:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt;#include \u0026lt;sys/ptrace.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/user.h\u0026gt; int main(int argc, char **argv) {  int child_pid;  child_pid = fork();  if (child_pid == 0)  {  // `PTRACE_TRACEME` 本进程将被其父进程跟踪(此时剩下的`pid、addr、data`参数都没有实际意义可以全部为 0)。  ptrace(PTRACE_TRACEME, 0, 0, 0);  execl(\u0026#34;/bin/ls\u0026#34;,\u0026#34;ls\u0026#34;,NULL); //执行系统调用  }  else  {  struct user_regs_struct regs;  wait(NULL);  printf(\u0026#34;child process was stopped ...\u0026#34;);  // 读取子进程寄存器集  ptrace(PTRACE_GETREGS, child_pid, NULL, \u0026amp;regs);  printf(\u0026#34;%llu\u0026#34;, regs.orig_rax);  // 恢复子进程  ptrace(PTRACE_CONT, child_pid, NULL, NULL);  sleep(1);  }  return 0; } 踩坑 SSHD 注入  https://github.com/xpn/ssh-inject\n 分析下代码其运行流程图整理如下：\ninject.c 和 injectme.c 中一些注入部分代码细节和 hook 代码细节已经看不懂了，先挖个坑吧\u0026hellip;\nLinux ptrace introduction AKA injecting into sshd for fun 原博客中有关于 ptarce 步骤更详细说明。\n笔记📒 进程相关：  pid_t fork(void) 在当前进程下分叉出子进程，其子进程的 pid 为 0 pid_t wait (int * status) 等待子进程中断或结束 pid_t waitpid(pid_t pid, int *status, int options);（等待子进程中断或结束）  pid: - pid\u0026lt;-1 等待进程组识别码为pid绝对值的任何子进程。 - pid=-1 等待任何子进程，相当于wait()。 - pid=0 等待进程组识别码与目前进程相同的任何子进程。 - pid\u0026gt;0 等待任何子进程识别码为pid的子进程。 status(子进程的结束状态返回后存于status，底下有几个宏可判别结束情况): - WIFEXITED(status) 如果子进程正常结束则为非0值。 - WEXITSTATUS(status) 取得子进程exit()返回的结束代码，一般会先用WIFEXITED 来判断是否正常结束才能使用此宏。 - WIFSIGNALED(status) 如果子进程是因为信号而结束则此宏值为真 - WTERMSIG(status) 取得子进程因信号而中止的信号代码，一般会先用WIFSIGNALED 来判断后才使用此宏。 - WIFSTOPPED(status) 如果子进程处于暂停执行情况则此宏值为真。一般只有使用 WUNTRACED 时才会有此情况。 - WSTOPSIG(status) 取得引发子进程暂停的信号代码，一般会先用WIFSTOPPED 来判断后才使用此宏。 options: 可以为 0 或下面的 OR 组合 - WNOHANG 如果没有任何已经结束的子进程则马上返回，不予以等待。 - WUNTRACED 如果子进程进入暂停执行情况则马上返回，但结束状态不予以理会。  exec 系列函数用来执行文件或者命令  #include \u0026lt;unistd.h\u0026gt;... int execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg, ..., char *const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); int execve(const char *path, char *const argv[], char *const envp[]); 注意： 系统调用 exec 是以新的进程去代替原来的进程，但进程的 PID 保持不变，只是替换了原来进程上下文的内容，原进程的代码段，数据段，堆栈段被新的进程所代替。\n动态加载 在 dlopen() 函数以指定模式打开指定的动态链接库文件，并返回一个句柄给 dlsym() 的调用进程。使用 dlclose() 来卸载打开的库。\n void * dlopen( const char *pathname, int mode ); ：打开一个动态链接库。  mode 是打开方式，其值有多个，不同操作系统上实现的功能有所不同，在 linux 下，按功能可分为三类：\n 解析方式  RTLD_LAZY：在 dlopen() 返回前，对于动态库中的未定义的符号不执行解析（只对函数引用有效，对于变量引用总是立即解析）。 RTLD_NOW： 需要在 dlopen() 返回前，解析出所有未定义符号，如果解析不出来，在 dlopen() 会返回 NULL，错误为：: undefined symbol: xxxx\u0026hellip;\u0026hellip;.   作用范围，可与解析方式通过 | 组合使用。  RTLD_GLOBAL：动态库中定义的符号可被其后打开的其它库解析。 RTLD_LOCAL： 与 RTLD_GLOBAL 作用相反，动态库中定义的符号不能被其后打开的其它库重定位。如果没有指明是 RTLD_GLOBAL还是 RTLD_LOCAL ，则缺省为 RTLD_LOCAL。   作用方式  RTLD_NODELETE： 在 dlclose() 期间不卸载库，并且在以后使用 dlopen() 重新加载库时不初始化库中的静态变量。这个flag不是POSIX-2001标准。 RTLD_NOLOAD： 不加载库。可用于测试库是否已加载( dlopen() 返回NULL说明未加载，否则说明已加载），也可用于改变已加载库的flag，如：先前加载库的flag为 RTLD_LOCAL，用 dlopen(RTLD_NOLOAD|RTLD_GLOBAL) 后flag将变成 RTLD_GLOBAL 。这个flag不是POSIX-2001标准。 RTLD_DEEPBIND：在搜索全局符号前先搜索库内的符号，避免同名符号的冲突。这个flag不是POSIX-2001标准。     void * dlsym(void *handle, const char *symbol)：dlsym() 根据动态链接库操作句柄 handle 与符号 symbol ，返回符号对应的地址。使用这个函数不但可以获取函数地址，也可以获取变量地址。  handle 是由 dlopen() 打开动态链接库后返回的指针，symbol 就是要求获取的函数或全局变量的名称。 返回值: void* 指向函数的地址，供调用使用。\n  dlclose() 用于关闭指定句柄的动态链接库，只有当此动态链接库的使用计数为 0 时,才会真正被系统卸载。\n  dlerror() 当动态链接库操作函数执行失败时，dlerror 可以返回出错信息，返回值为 NULL 时表示操作函数执行成功。\n  内存相关  void * malloc(size_t size)：分配所需的内存空间，并返回一个指向它的指针；记得需要运行 free(addr` ) void * memcpy(void *dest, const void *src, size_t num);： 会复制 src 所指的内存内容的前 num 个字节到 dest 所指的内存地址上。  字符处理  int snprintf(char *str, size_t size, const char *format, ...);  设将可变参数 ... 按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断。\n char *strstr(const char *haystack, const char *needle);  在字符串 haystack 中查找第一次出现字符串 needle 的位置，不包含终止符 \u0026lsquo;\\0\u0026rsquo;。该函数返回在 haystack 中第一次出现 needle 字符串的位置，如果未找到则返回 null。\n unsigned long int strtoul(const char *str, char **endptr, int base);  把参数 str 所指向的字符串根据给定的 base 转换为一个无符号长整数（类型为 unsigned long int 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0。\n int sscanf(const char *str, const char *format, ...); 从字符串读取格式化输入。  其他  struct 运算符 . 和箭头运算符 -\u0026gt; 异同点：  相同点：两者都是二元操作符，而且右边的操作数都是成员的名称。 不同点：点运算符 . 的左边操作数是一个结果为结构的表达式； 箭头运算符 -\u0026gt; 的左边的操作数是一个指向结构体的指针。    总结 浅显的认知 Linux 下进程运行的机制，ptrace 的如何动态注入基本过程，C语言的基本用法等。。。\n参考文章🙏  linux ptrace wiki linux ptrace 手册 linux wait waitpid 手册 《Linux逆向之调试\u0026amp;反调试》 《Linux虚拟地址空间布局以及进程栈和线程栈总结》 Linux ptrace introduction AKA injecting into sshd for fun https://github.com/xpn/ssh-inject  ","permalink":"https://zznq.imipy.com/posts/linux-ptrace-learning/","title":"Linux ptrace机制初探"},{"content":"如何代理 http(s) 流量 HTTP 代理的协议基于 HTTP，因此 HTTP 代理本身就是一个 HTTP 的服务，而其工作原理本质上就是中间人（MITM) ，即读取当前客户端的 HTTP 请求，从代理发送出去并获得响应，然后将响应返回给客户端。\n 使用 netcat -lv -p 8881 监听 127.0.0.1:8881\n  访问 http://**.** nc 的数据包为:  GET http://hyuga.co/ HTTP/1.1 Host: hyuga.co Proxy-Connection: keep-alive Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://hyuga.co/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 ...  访问 https://**.** nc 的数据包为:  CONNECT github.com:443 HTTP/1.1 Host: github.com:443 Proxy-Connection: keep-alive User-Agent: Mozilla/5.0 golang 实现 http(s) 代理服务器 使用隧道直接双向复制 https 数据\npackage main  import ( \t\u0026#34;io\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;net\u0026#34; \t\u0026#34;net/http\u0026#34; )  const addr = \u0026#34;localhost:8881\u0026#34;  func main() { \tlog.Printf(\u0026#34;HTTPProxy is runing on %s \\n\u0026#34;, addr) \tlog.Fatalln(http.ListenAndServe(addr, http.HandlerFunc(handler))) }  func handler(rw http.ResponseWriter, req *http.Request) { \t// http \u0026amp;\u0026amp; https \tif req.Method != \u0026#34;CONNECT\u0026#34; { \t// 处理http \thandleHTTP(rw, req) \t} else { \t// 处理https \thandleHTTPS(rw, req) \t} }  func handleHTTP(rw http.ResponseWriter, req *http.Request) { \ttransport := http.DefaultTransport \t// 新建一个请求outReq \toutReq := new(http.Request) \t// 复制客户端请求到outReq上 \t*outReq = *req // 复制请求 \t// outReq 请求放到传送上 \tres, err := transport.RoundTrip(outReq) \tif err != nil { \trw.WriteHeader(http.StatusBadGateway) \trw.Write([]byte(err.Error())) \treturn \t} \t// 回写 http 头 \tfor key, value := range res.Header { \tfor _, v := range value { \trw.Header().Add(key, v) \t} \t} \t// 回写状态码 \trw.WriteHeader(res.StatusCode) \t// 回写 body \tio.Copy(rw, res.Body) \tres.Body.Close() }  func handleHTTPS(rw http.ResponseWriter, req *http.Request) { \thost := req.URL.Host \thij, ok := rw.(http.Hijacker) \tif !ok { \tlog.Printf(\u0026#34;HTTP Server does not support hijacking\u0026#34;) \t} \tclient, _, err := hij.Hijack() \tif err != nil { \treturn \t} \t// 连接远程 \tserver, err := net.Dial(\u0026#34;tcp\u0026#34;, host) \tif err != nil { \treturn \t} \tclient.Write([]byte(\u0026#34;HTTP/1.0 200 Connection Established\\r\\n\\r\\n\u0026#34;)) \t// 直通双向复制 \tgo io.Copy(server, client) \tgo io.Copy(client, server) } 但作为被动扫描器的代理，https 协议的请求数据都是加密的，大部分的网站都无法进行漏洞检测了，所以被动扫描器的代理还需要对 https 流量进行加解密。\nHTTP \u0026amp; HTTPS 的区别   HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。\n  HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。\n  HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：\n TCP 三次同步握手 客户端验证服务器数字证书 DH 算法协商对称加密算法的密钥、hash 算法的密钥 SSL 安全加密隧道协商完成 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。  什么是证书 最顶层的 Global Sign RootCA 是一个根证书，第二个是一个中间证书，最后一个才是用户的颁发证书，这三种证书的效力是:\nRootCA \u0026gt; Intermediates CA \u0026gt; End-User Cert  而且只要信任了 RootCA 由 RootCA 签发的包括其下级签发的证书都会被信任。而 Global Sign RootCA 等是一些默认安装在系统和浏览器中的根证书。这些证书由一些权威机构来维护，可以确保证书的安全和有效性。而内置的这些根证书就允许我们访问一些公共的网站而无需手动信任证书了。\n什么是x509证书链 x509证书一般会用到三类文件，key，csr，crt。\nKey 是私用密钥，openssl 格式，通常是 rsa 算法。\ncsr 是证书请求文件，用于申请证书。在制作 csr 文件的时候，必须使用自己的私钥来签署申请，还可以设定一个密钥。\ncrt 是 CA 认证后的证书文件，签署人用自己的key给你签署的凭证。\n如何生成证书 openssl 中有如下后缀名的文件\n .key格式：私有的密钥 .csr格式：证书签名请求（证书请求文件），含有公钥信息，certificate signing request的缩写 .crt格式：证书文件，certificate的缩写 .crl格式：证书吊销列表，Certificate Revocation List的缩写 .pem格式：用于导出，导入证书时候的证书的格式，有证书开头，结尾的格式  使用如下命令生成证书：\nopenssl genrsa -out ca/rootCA.key 2048 openssl req -new -key ca/rootCA.key -out ca/rootCA.csr openssl x509 -req -days 3650 -in ca/rootCA.csr -signkey ca/rootCA.key -in rootCA.csr -out ca/rootCA.crt 如何信任证书 只列举了 MacOS 下的情况（其他操作系统自行搜索：\n 使用命令  sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain ca/rootCA.crt  打开“钥匙串访问”；系统-\u0026gt;证书-\u0026gt;添加；双击添加的证书-\u0026gt;信任-\u0026gt;始终信任。  golang 如何代理并解密 https 流量 挑选一个轻量 goproxy 项目进行源码分析：\n证书相关：\n// Cache 证书缓存接口 type Cache interface { \tSet(host string, c *tls.Certificate) \tGet(host string) *tls.Certificate } //证书 struct type Certificate struct { \tcache Cache } // NewCertificate 创建证书 func NewCertificate(cache Cache) *Certificate { \treturn \u0026amp;Certificate{ \tcache: cache, \t} } GenerateTlsConfig 根据根证书生成子证书，并写入 cache 中\n// GenerateTlsConfig 生成TLS配置 func (c *Certificate) GenerateTlsConfig(host string) (*tls.Config, error) { \tif h, _, err := net.SplitHostPort(host); err == nil { \thost = h \t} \tif c.cache != nil { \t// 先从缓存中查找证书 \tif cert := c.cache.Get(host); cert != nil { \ttlsConf := \u0026amp;tls.Config{ \tCertificates: []tls.Certificate{*cert}, \t}  \treturn tlsConf, nil \t} \t} \tpair, err := c.GeneratePem(host, 1, defaultRootCA, defaultRootKey) \tif err != nil { \treturn nil, err \t} \tcert, err := tls.X509KeyPair(pair.CertBytes, pair.PrivateKeyBytes) \tif err != nil { \treturn nil, err \t} \ttlsConf := \u0026amp;tls.Config{ \tCertificates: []tls.Certificate{cert}, \t}  \tif c.cache != nil { \t// 缓存证书 \tc.cache.Set(host, \u0026amp;cert) \t}  \treturn tlsConf, nil } 先定位到 server handler 方法：\nfunc (p *Proxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) { \t... \tctx := \u0026amp;Context{ \tReq: req, \tData: make(map[interface{}]interface{}), \t} \t... \tswitch { \tcase ctx.Req.Method == http.MethodConnect \u0026amp;\u0026amp; p.decryptHTTPS: \tp.forwardHTTPS(ctx, rw) \tcase ctx.Req.Method == http.MethodConnect: \tp.forwardTunnel(ctx, rw) \tdefault: \tp.forwardHTTP(ctx, rw) \t} }  forwardHTTPS: 解密 https 请求 forwardTunnel: 隧道直连 forwardHTTP: 处理普通 http 请求  forwardHTTPS 方法:\n// HTTPS转发 func (p *Proxy) forwardHTTPS(ctx *Context, rw http.ResponseWriter) { \tvar err error \t// 获取底层连接 \thijacker, ok := rw.(http.Hijacker) \tif !ok { \terr = fmt.Errorf(\u0026#34;web server不支持Hijacker\u0026#34;) \t} \tclientConn, _, err := hijacker.Hijack() \tif err != nil { \terr = fmt.Errorf(\u0026#34;hijacker错误: %s\u0026#34;, err) \t} \t// handler errors \tif err != nil { \tp.delegate.ErrorLog(err) \trw.WriteHeader(http.StatusBadGateway) \treturn \t} \tdefer clientConn.Close() \t\t// 隧道连接成功响应行 \t_, err = clientConn.Write([]byte(\u0026#34;HTTP/1.1 200 Connection established\\r\\n\\r\\n\u0026#34;)) \tif err != nil { \tp.delegate.ErrorLog(fmt.Errorf(\u0026#34;%s - HTTPS解密, 通知客户端隧道已连接失败, %s\u0026#34;, ctx.Req.URL.Host, err)) \treturn \t} \t// 获取子证书 \ttlsConfig, err := p.cert.GenerateTlsConfig(ctx.Req.URL.Host) \tif err != nil { \tp.delegate.ErrorLog(fmt.Errorf(\u0026#34;%s - HTTPS解密, 生成证书失败: %s\u0026#34;, ctx.Req.URL.Host, err)) \trw.WriteHeader(http.StatusBadGateway) \treturn \t} \t// 获取一个 TLS Server 新连接 \ttlsClientConn := tls.Server(clientConn, tlsConfig) \ttlsClientConn.SetDeadline(time.Now().Add(defaultClientReadWriteTimeout)) \tdefer tlsClientConn.Close() \tif err := tlsClientConn.Handshake(); err != nil { \tp.delegate.ErrorLog(fmt.Errorf(\u0026#34;%s - HTTPS解密, 握手失败: %s\u0026#34;, ctx.Req.URL.Host, err)) \treturn \t} \t// 解密 https reqeust \tbuf := bufio.NewReader(tlsClientConn) \ttlsReq, err := http.ReadRequest(buf) \tif err != nil { \tif err != io.EOF { \tp.delegate.ErrorLog(fmt.Errorf(\u0026#34;%s - HTTPS解密, 读取客户端请求失败: %s\u0026#34;, ctx.Req.URL.Host, err)) \t} \treturn \t} \ttlsReq.RemoteAddr = ctx.Req.RemoteAddr \ttlsReq.URL.Scheme = \u0026#34;https\u0026#34; \ttlsReq.URL.Host = tlsReq.Host  \tctx.Req = tlsReq \tp.DoRequest(ctx, func(resp *http.Response, err error) { \tif err != nil { \tp.delegate.ErrorLog(fmt.Errorf(\u0026#34;%s - HTTPS解密, 请求错误: %s\u0026#34;, ctx.Req.URL, err)) \ttlsClientConn.Write(badGateway) \treturn \t} \t// 写入 response \terr = resp.Write(tlsClientConn) \tif err != nil { \tp.delegate.ErrorLog(fmt.Errorf(\u0026#34;%s - HTTPS解密, response写入客户端失败, %s\u0026#34;, ctx.Req.URL, err)) \t} \tresp.Body.Close() \t}) } DoRequest 方法代码如下：\n// DoRequest 执行HTTP请求，并调用responseFunc处理response func (p *Proxy) DoRequest(ctx *Context, responseFunc func(*http.Response, error)) { \tif ctx.Data == nil { \tctx.Data = make(map[interface{}]interface{}) \t} \tif ctx.abort { \treturn \t} \tnewReq := new(http.Request) \t*newReq = *ctx.Req \tnewReq.Header = CloneHeader(newReq.Header) \tremoveConnectionHeaders(newReq.Header) \tfor _, item := range hopHeaders { \tif newReq.Header.Get(item) != \u0026#34;\u0026#34; { \tnewReq.Header.Del(item) \t} \t} \tresp, err := p.transport.RoundTrip(newReq) \tif ctx.abort { \treturn \t} \tif err == nil { \tremoveConnectionHeaders(resp.Header) \tfor _, h := range hopHeaders { \tresp.Header.Del(h) \t} \t} \tresponseFunc(resp, err) } 如上，完成这一 https 解密过程还是很方便的，当然像《HTTP被动扫描代理的那些事》中说的“#离完美的差距“，这次的初探是为了满足对被动扫描器代理部分的好奇🤔。。。\n参考文章  《深入理解HTTPS工作原理》https://juejin.cn/post/6844903830916694030 《HTTP被动扫描代理的那些事》https://www.freebuf.com/articles/web/212382.html 《HTTP 与 HTTPS 的区别》https://www.runoob.com/w3cnote/http-vs-https.html 《别闹！自签名证书！》https://zhuanlan.zhihu.com/p/41501360 《Linux专题—Openssl生成证书》https://zhuanlan.zhihu.com/p/104212822 https://github.com/ouqiang/goproxy  ","permalink":"https://zznq.imipy.com/posts/passive-scanner-https-proxy/","title":"被动扫描器HTTP(S)代理初探"},{"content":"虽然之前有用 React 编写了 Hyuga 的前端，但是都是靠的 google + github 解决的，认知很浅。\n前端基础  https://developer.mozilla.org/zh-CN/ 别说了就是多看文档\n HTML  块级元素 自占一行 内联元素的大小就是被包裹元素的大小 \u0026lt;head\u0026gt; 中的 \u0026lt;base target=\u0026quot;_blank\u0026quot; /\u0026gt; 定义所有的链接属性  CSS 基础  https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference#%E5%85%B3%E9%94%AE%E5%AD%97%E7%B4%A2%E5%BC%95\n 载入 CSS 的几种方法  内联 inline Style 标签 独立文件  css 选择器 https://segmentfault.com/a/1190000013424772\n常用的选择器：\n  元素选择器\np{...} div{...} 等\n  类选择器\n.class_name{...}\n  ID 选择器 #id_name{...}\n  属性选择器\na[id=\u0026quot;xxx\u0026quot;]{...}\n  伪元素选择器\n.content::after{...}\n  伪类选择器\na:link{...}\n  a 标签:\n link: 原来的颜色 active: 点击时 visited: 点击后 hover: 鼠标移至链接(focus)  a:link {  color: green; } a:active {  color: black; } a:visited {  color: orange; } a:hover {  color: yellow; } 标签组合\n A \u0026gt; B：选择 A 下一层的元素 B A ~ B：选择与 A 同父层的元素 B A + B：选择与 A 相邻的元素 B(不能被任何元素相隔) A B：包含选择，A 元素下所有的 B 元素  常见的 CSS 字体 字体样式（使用系统字体样式）\nbody {  font-family: -apple-system, BlinkMacSystemFont, \u0026#34;Segoe UI\u0026#34;, Roboto,  \u0026#34;Helvetica Neue\u0026#34;, Helvetica, \u0026#34;PingFang SC\u0026#34;, \u0026#34;Hiragino Sans GB\u0026#34;,  \u0026#34;Microsoft YaHei\u0026#34;, SimSun, sans-serif; } /* 颜色 */ h2 {  color: #4d9ef8; } /* 文字对齐 */ h2 {  text-align: center; } /* 文字装饰 */ h2 {  text-decoration: underline; } /* 首行缩进 */ p {  text-indent: 20px; } /* 行间距 */ p {  line-height: 1.8; } /* 字间距 */ h2 {  letter-spacing: 5px; } 换行 中文与英文在超长的情况下会自动换行；\ndiv.bg {  word-wrap: break-word; } Box 模型 Box 模型溢出\n 隐藏 overflow:hidden 自动添加滚动条 overflow:auto 总是显示滚动条 overflow:scroll 水平与垂直方向 overflow-x, overflow-y  Position JavaScript 版本特征:\n   ECMAScript 版本 发布时间 新增特性     ECMAScript 2009(ES5) 2009.11 扩展了 Object、Array、Function 的功能等   ECMAScript 2015(ES6) 2015.6 类，模块化，箭头函数，函数参数默认值等   ECMAScript 2016(ES7) 2016.3 inclueds，指数操作符   ECMAScript 2017(ES8) 2017.6 sync/await, Object.values(), Object.entries(), String padding 等    浏览器对 Es6 各种特性支持的图表 http://kangax.github.io/compat-table/es6/\n数据类型：\n   类型 desc     数值 整型、浮点、双精度、isNaN   字符串 \u0026ldquo;双引号\u0026rdquo;、 \u0026lsquo;单引号\u0026rsquo;   数组 [var1, va2]   对象 {key: \u0026ldquo;value\u0026rdquo;}   弱类型 typeof、parseInt、parseFloat    变量定义：\n 全局：var 作用域：let变量 \u0026amp; const常量 解构赋值：let{a,b} = {a:1, b:2}  操作符：\n 算术运算：加减乘除、++/\u0026ndash;、+=、取模 比较运算：\u0026gt;、\u0026lt;、!=、==、 !==、 ===、 ? 逻辑运算：\u0026amp;\u0026amp;、||、! 位运算：\u0026amp;、|、\u0026raquo;、\u0026laquo; 字符串运算：+  面向对象： class salaryData{  // 构造函数  constructor( city , position , salary_max , salary_min ){  this.city = city;  this.position = position;  this.salary_max = salary_max;  this.salary_min = salary_min;  }  // 方法  avg_salary(){  return (this.salary_min + this.salary_max)/2;  } } // make new let sh_fe = new salaryData( \u0026#39;shanghai\u0026#39; , \u0026#39;fe\u0026#39; , 14398 , 24675 ); console.log( sh_fe.avg_salary() );  // 继承 class capitalSalaryData extends salaryData{  constructor( city , position , salary_max , salary_min ){ // 调用父类  super( city , position , salary_max , salary_min );  }  pure_income(){  return this.avg_salary()*0.55;  } } 公有、私有、保护属性和方法 约定：可以使用 _, __ 字符为前缀\ngetter / setter class salaryData{  constructor( city , position , salary_max , salary_min ){  this.city = city;  this.position = position;  this.salary_max = salary_max;  this.salary_min = salary_min;  }  get avg_salary(){  return (this.salary_min + this.salary_max)/2;  }  get pure_income(){  return this.avg_salary()*0.55;  } } // make new let sh_fe = new salaryData( \u0026#39;shanghai\u0026#39; , \u0026#39;fe\u0026#39; , 14398 , 24675 ); console.log( sh_fe.avg_salary ); setter: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set\nthis 和 箭头函数 // 在全局上下文中，this 指代的是 window // 函数中默认调用，使用全局上下文 function testThis(o){  console.log(this.title); } testThis(); // 使用 call 或者 apply，强制 this 使用函数上下文，这时 this === o testThis.call({title:\u0026#34;title1\u0026#34;}); testThis.apply({title:\u0026#34;title2\u0026#34;}); // ES5 引入 bind 方法，可以动态的从一个旧函数创建一个新函数，并把这个函数的 this，绑定到 bind 的第一个参数上 testThis.bind({title:\u0026#34;title3\u0026#34;})();  // 在箭头函数中，this 保留外部的上下文的值。 var testThis1 = () =\u0026gt; {console.log(this.title)}; testThis1(); // 其他调用方式都无法改变 testThis1({title:\u0026#34;title4\u0026#34;}); testThis1.call({title:\u0026#34;title4\u0026#34;}); testThis1.bind({title:\u0026#34;title4\u0026#34;})();  // 通过对象.方法() 来调用时，this 会绑定对象上。 var book = new Object; book.name = \u0026#34;《富爸爸，穷爸爸》\u0026#34;; book.read = function(){  console.log(this.name); } book.read(); 模块与包 ES6 后 JavaScript 开始支持通过 import 来导入其他的模块\n module, export, import  DOM window 在浏览器里运行 JavaScript 默认对象就是 window 使用其属性与方法时可省略掉 window. 。\n 地址栏：location.href, location.reload 交互操作：alert, confirm, prompt 大小和位置： outerHeight, outerWidth, innerHeight, innerWidth 滚动：scroll, scrollBy, scrollTo, scrollX, scrollY 窗口：open, opener, parent  event 事件 https://devdocs.io/dom_events/\nJQuery 中文文档：https://www.jquery123.com/\nNode 中文文档：http://nodejs.cn/\n编写简单的 WebServer Demo:\nconst http = require(\u0026#34;http\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;);  const server = http.createServer();  server.on(\u0026#34;request\u0026#34;, (req, resp) =\u0026gt; {  const ext = path.extname(req.url);  let doc_path = path.join(__dirname, \u0026#34;root\u0026#34;, req.url);  console.log(req.url, doc_path);  let content;  let status = 200;  let mime = { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/html\u0026#34; };  switch (ext) {  case \u0026#34;.html\u0026#34;:  case \u0026#34;.htm\u0026#34;:  mime = { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/html\u0026#34; };  break;  case \u0026#34;.css\u0026#34;:  mime = { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/css\u0026#34; };  break;  case \u0026#34;.ico\u0026#34;:  mime = { \u0026#34;Content-Type\u0026#34;: \u0026#34;image/x-icon\u0026#34; };  break;  }   if (ext != \u0026#34;\u0026#34; \u0026amp;\u0026amp; fs.existsSync(doc_path)) {  content = fs.readFileSync(doc_path);  } else {  status = 404;  content = \u0026#34;文件不存在\u0026#34;;  }  resp.writeHead(status, mime);  resp.write(content);  resp.end(); });  server.listen(8080); NodeJS 的基本结构 React Export 存在两种 exports 导出方式：\n 命名导出（每个模块包含任意数量） 默认导出（每个模块包含一个）(注意，不能使用 var、let 或 const 用于导出默认值 export default。)  在导出多个值时，命名导出非常有用。在导入期间，必须使用相应对象的相同名称。但是，可以使用任何名称导入默认导出。\nImport 一个组件的生命周期 constructor：构造函数 componentDidMount：组件第一次渲染时的挂载 componentWillUnmount：组件被删除时的卸载\n正确的更新 state：https://zh-hans.reactjs.org/docs/state-and-lifecycle.html#using-state-correctly\n关于组件数据流：https://zh-hans.reactjs.org/docs/state-and-lifecycle.html#the-data-flows-down\n","permalink":"https://zznq.imipy.com/posts/frontend-learning/","title":"前端入门小记"}]