<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>逆向 on zznQ</title><link>https://zznq.imipy.com/categories/%E9%80%86%E5%90%91/</link><description>Recent content in 逆向 on zznQ</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 04 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://zznq.imipy.com/categories/%E9%80%86%E5%90%91/index.xml" rel="self" type="application/rss+xml"/><item><title>记录一次破解[macOS]Typora失败的经历</title><link>https://zznq.imipy.com/posts/failed-to-crack-typora/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate><guid>https://zznq.imipy.com/posts/failed-to-crack-typora/</guid><description>在破解Bartender4后没多久躁动地心又开始了这次就尝试破解macOS下的Typora，顺便记录一下。
搜索相关文章看到成功破解 Win、Linux(Electron)的文章以及工具： https://blog.shi1011.cn/rev/1891 https://github.com/Mas0nShi/typoraCracker 文章中分析（win｜linux）addLicense 流程如下，macOS 上使用原生 webkit 开发，估计思路差不多：
直接打开 Hopper 分析搜索 License 找到了 LicenseManager 类：
看到一个关键字为 activate 的方法，签名如下：
/* @class LicenseManager */ -(void)activate:(void *)arg2 with:(void *)arg3 force:(char)arg4 callback:(void *)arg5 { /* - arg2 -&amp;gt; email - arg3 -&amp;gt; license - arg4 -&amp;gt; force - arg5 -&amp;gt; callback */ 分析 LicenseManager.activate 其方法流程：
但是我不知道传入的 callback 是什么，为了搞清楚整个流程，想使用 firda 来打印下activate传入的参数：
$ frida-trace -i &amp;#34;activate*&amp;#34; Typora Attaching... [1] 4229 killed frida-trace -i &amp;#34;activate*&amp;#34; Typora 进程直接被杀掉了 emmm 算逑！继续静态分析吧。</description></item><item><title>逆向获取 MacOS WeChat App 聊天数据库密钥小记</title><link>https://zznq.imipy.com/posts/wechat-sqlite-key/</link><pubDate>Thu, 15 Jul 2021 00:00:00 +0000</pubDate><guid>https://zznq.imipy.com/posts/wechat-sqlite-key/</guid><description>突然想解密下 WeChat 本地聊天数据库 ，这些 msg_*.db 文件一般存在 ~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application\ Support/com.tencent.xinWeChat/2.*******/123812fsdhg1232333sd/Message/ 目录下
google 发现一个教程：https://github.com/allen1881996/WeChat-Data-Analysis 测试后发现这个操作是可行的。大概步骤如下：通过 lldb 动态调试对 sqlite3_key 函数断点后再读取 $rsi 寄存器的值，进行简单拼接即得到了 sqlite3 raw-key。
但是心中出现了两个疑问：
为什么是 sqlite3_key? Tencent有个开源项目 wcdb 是基于SQLite的，加密使用的是开源的 SQLCipher sqlite3_key 函数就是设置加密数据库的。wcdb 将其封装在了 setCipherKey 方法下。
memory read --size 1 --format x --count 32 $rsi 是啥意思？ x86-64 中函数调用时的参数存储如下寄存器中: %rdi, %rsi, %rdx, %rcx, %r8, %r9 六个寄存器用于存储函数调用时的6个参数（如果有6个或6个以上参数的话）。
%rsi 寄存器存储的为第二个参数，即对应 int sqlite3_key(sqlite3 *db, const void *pKey, int nKey); 中 key 。
如何能通过静态的方式获取到 key 呢？ 根据 WCDB 的线索继续摸索，找到在哪里执行 setCipherKey</description></item><item><title>MacOS - Electron 应用分析小记</title><link>https://zznq.imipy.com/posts/macos-electron-analysis/</link><pubDate>Wed, 12 May 2021 00:00:00 +0000</pubDate><guid>https://zznq.imipy.com/posts/macos-electron-analysis/</guid><description>查看包内容，在Resources 目录下找到 app.asar 文件
解压 app.asar 文件
$ npm install asar -g $ cd /Applications/AppName.app/Contents/Resources $ asar e app.asar appCore 进入到与app.asar.unpacked的同级目录下，不然会有如下错误：https://github.com/electron/asar/issues/37
解包之后目录如下
ls -lahrt total 8 drwxr-xr-x@ 64 staff 2.0K May 4 11:09 .. -rw-r--r-- 1 staff 984B May 4 11:09 package.json drwxr-xr-x 3 staff 96B May 4 11:09 dist drwxr-xr-x 5 staff 160B May 4 11:09 . drwxr-xr-x 166 staff 5.2K May 4 11:09 node_modules 源码在 dist/electron 下；一般这里的 js 都是经过混淆，逻辑需要进行具体的分析&amp;hellip;</description></item></channel></rss>