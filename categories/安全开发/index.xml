<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>安全开发 on zznQ</title><link>https://zznq.imipy.com/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/</link><description>Recent content in 安全开发 on zznQ</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 25 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://zznq.imipy.com/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>golang web audit 小记</title><link>https://zznq.imipy.com/posts/golang-web-audit/</link><pubDate>Tue, 25 May 2021 00:00:00 +0000</pubDate><guid>https://zznq.imipy.com/posts/golang-web-audit/</guid><description>&lt;p>简单记录下Golang web代码审计。&lt;/p></description></item><item><title>cgo &amp; objc</title><link>https://zznq.imipy.com/posts/cgoobjc/</link><pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate><guid>https://zznq.imipy.com/posts/cgoobjc/</guid><description>我尝试用 golang 编写一些核心代码，再利用 cgo 的特性将其打包成 dylib 文件，以便于我在objc 中调用（因为我 objc 写的很烂）。
先写个很简单的 cgo 程序 main.go ：
package main //void HelloWorld(); import &amp;#34;C&amp;#34; import &amp;#34;fmt&amp;#34; //export HelloWorld func HelloWorld() { fmt.Println(&amp;#34;Hello World!!!&amp;#34;) } func main() {} 代码中有几个地方需要注意下：
import &amp;quot;C&amp;quot; 语句则表示开启了CGO特性 //export HelloWorld CGO 指令将其导出为C语言函数 编译为dylib动态库： $ go build -buildmode=c-shared--ldflags=&amp;quot;-w -s&amp;quot; -o cgodemo.dylib cgoDemo/main.go
查看下文件信息：
$ file cgodemo.dylib cgodemo.dylib: Mach-O 64-bit dynamically linked shared library x86_64 $ otool -L cgodemo.</description></item><item><title>cel-go 初探</title><link>https://zznq.imipy.com/posts/cel-go-demo/</link><pubDate>Wed, 12 May 2021 00:00:00 +0000</pubDate><guid>https://zznq.imipy.com/posts/cel-go-demo/</guid><description>之前看到 Xray - 如何编写expression表达式 提到这个库 https://github.com/google/cel-spec
正好工作方面也遇到这个需求了，就来简单的研究下，先看下相关资料：
cel-spec 介绍 cel-go github cel-go 入门文档 cel 是建立 protocol 之上的。
在 demo 项目下创建 fprint 包；并在其目录下创建 fprint.proto 文件
syntax = &amp;#34;proto3&amp;#34;;package fprint; // https://developers.google.com/protocol-buffers/docs/proto3#packages option go_package = &amp;#34;fprint/bp&amp;#34;; // golang package 包名 message Response { string url = 1; int32 status = 2 ; map&amp;lt;string, string&amp;gt; headers = 3; string content_type = 4; string title = 5; bytes body = 6; string md5 = 7;}使用 $ protoc --go_out=.</description></item><item><title>Linux ptrace机制初探</title><link>https://zznq.imipy.com/posts/linux-ptrace-learning/</link><pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate><guid>https://zznq.imipy.com/posts/linux-ptrace-learning/</guid><description>补充下基础知识 动态加载 动态加载Dynamic Loading：是一种程序运行机制，能让计算机程序在运行时（而不是编译时）装载库（或者其他二进制对象）到内存中，然后检索库中函数和变量的地址，并运行这些函数或访问这些变量，且能在不需要时将库从内存中卸载。
linux下的/proc虚拟文件系统 Linux 内核提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。
/proc/&amp;lt;PID&amp;gt;/status / /proc/&amp;lt;PID&amp;gt;/stat： 查看进程信息 /proc/&amp;lt;PID&amp;gt;/maps：进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表 /proc/self/maps： 当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。 什么是 Ptrace？ 通过使用 ptrace（名称是 &amp;ldquo;process trace&amp;rdquo; 的缩写），一个进程可以控制另一个进程，从而使控制器能够检查和操纵目标的内部状态。
linux ptrace 函数提供了许多有用的调试操作：
PTRACE_ATTACH 允许一个进程将自身附加到另一个进程进行调试，从而暂停远程进程。 PTRACE_PEEKTEXT 允许从另一个进程地址空间读取内存。 PTRACE_POKETEXT 允许将内存写入另一个进程地址空间。 PTRACE_GETREGS 从进程中读取当前的处理器寄存器集。 PTRACE_SETREGS 写入进程的当前处理器寄存器集。 PTRACE_CONT 恢复附加进程的执行。 PTRACE_DETACH 是重新启动操作；它要求目标进程处于 ptrace-stop 中。 函数签名：
long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); 🌰 （Linux ubuntu 4.15.0-112-generic x86_64）:
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/wait.h&amp;gt;#include &amp;lt;sys/ptrace.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/user.h&amp;gt; int main(int argc, char **argv) { int child_pid; child_pid = fork(); if (child_pid == 0) { // `PTRACE_TRACEME` 本进程将被其父进程跟踪(此时剩下的`pid、addr、data`参数都没有实际意义可以全部为 0)。 ptrace(PTRACE_TRACEME, 0, 0, 0); execl(&amp;#34;/bin/ls&amp;#34;,&amp;#34;ls&amp;#34;,NULL); //执行系统调用 } else { struct user_regs_struct regs; wait(NULL); printf(&amp;#34;child process was stopped .</description></item><item><title>被动扫描器HTTP(S)代理初探</title><link>https://zznq.imipy.com/posts/passive-scanner-https-proxy/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://zznq.imipy.com/posts/passive-scanner-https-proxy/</guid><description>如何代理 http(s) 流量 HTTP 代理的协议基于 HTTP，因此 HTTP 代理本身就是一个 HTTP 的服务，而其工作原理本质上就是中间人（MITM) ，即读取当前客户端的 HTTP 请求，从代理发送出去并获得响应，然后将响应返回给客户端。
使用 netcat -lv -p 8881 监听 127.0.0.1:8881
访问 http://**.** nc 的数据包为: GET http://hyuga.co/ HTTP/1.1 Host: hyuga.co Proxy-Connection: keep-alive Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://hyuga.co/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 ... 访问 https://**.** nc 的数据包为: CONNECT github.com:443 HTTP/1.1 Host: github.com:443 Proxy-Connection: keep-alive User-Agent: Mozilla/5.0 golang 实现 http(s) 代理服务器 使用隧道直接双向复制 https 数据</description></item></channel></rss>